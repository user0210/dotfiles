diff --git a/dwm.c b/dwm.c
index a4177e7..7b62ab1 100644
--- a/dwm.c
+++ b/dwm.c
@@ -21,18 +21,18 @@
  * To understand everything else, start reading main().
  */
 #include <errno.h>
+#include <limits.h>
 #include <locale.h>
-#include <math.h>
 #include <signal.h>
 #include <stdarg.h>
+#include <stdint.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
-#include <limits.h>
-#include <stdint.h>
 #include <sys/types.h>
 #include <sys/wait.h>
+#include <time.h>
 #include <X11/cursorfont.h>
 #include <X11/keysym.h>
 #include <X11/Xatom.h>
@@ -68,6 +68,8 @@
 #define HEIGHT(X)               ((X)->h + 2 * (X)->bw)
 #define TAGMASK                 ((1 << LENGTH(tags)) - 1)
 #define TEXTW(X)                (drw_fontset_getwidth(drw, (X)) + lrpad)
+
+/* patch - definitions */
 #define XRDB_LOAD_COLOR(R,V)    if (XrmGetResource(xrdb, R, NULL, &type, &value) == True) { \
                                   if (value.addr != NULL && strnlen(value.addr, 8) == 7 && value.addr[0] == '#') { \
                                     int i = 1; \
@@ -106,10 +108,10 @@
 /* enums */
 enum { Manager, Xembed, XembedInfo, XLast }; /* Xembed atoms */
 enum { CurNormal, CurResize, CurMove, CurResizeHorzArrow, CurResizeVertArrow, CurLast }; /* cursor */
-enum { SchemeBar, SchemeTag, SchemeBorder, SchemeSelect, SchemeFocus, SchemeUnfocus }; /* color schemes */
+enum { SchemeBar, SchemeSelect, SchemeBorder, SchemeFocus, SchemeUnfocus, SchemeTag }; /* color schemes */
 enum { NetSupported, NetSystemTray, NetSystemTrayOP, NetSystemTrayOrientation, NetSystemTrayVisual,
-	   NetWMName, NetWMIcon, NetWMState, NetWMFullscreen, NetActiveWindow, NetWMWindowType, NetWMWindowTypeDock,
-	   NetSystemTrayOrientationHorz, NetWMWindowTypeDialog, NetClientList, NetWMCheck, NetLast }; /* EWMH atoms */
+       NetWMName, NetWMIcon, NetWMState, NetWMFullscreen, NetActiveWindow, NetWMWindowType, NetWMWindowTypeDock,
+       NetSystemTrayOrientationHorz, NetWMWindowTypeDialog, NetClientList, NetWMCheck, NetLast }; /* EWMH atoms */
 enum { WMProtocols, WMDelete, WMState, WMTakeFocus, WMLast }; /* default atoms */
 enum { ClkTagBar, ClkLtSymbol, ClkStatusText, ClkNotifyText,
        ClkClientWin, ClkRootWin, ClkLast }; /* clicks */
@@ -133,6 +135,7 @@ typedef struct Monitor Monitor;
 typedef struct Client Client;
 struct Client {
 	char name[256];
+	char scratchkey;
 	float mina, maxa;
 	float cfact;
 	int x, y, w, h;
@@ -140,13 +143,11 @@ struct Client {
 	int oldx, oldy, oldw, oldh;
 	int basew, baseh, incw, inch, maxw, maxh, minw, minh;
 	int bw, oldbw;
-	unsigned int tags;
-	unsigned int switchtotag;
-	float floatx, floaty, floatw, floath;
 	int floatborderpx;
-	int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen, isactfullscreen, isterminal, noswallow;
+	unsigned int tags;
+	unsigned int switchtag;
+	int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen, isterminal, noswallow;
 	int ignorecfgreqpos, ignorecfgreqsize;
-	char scratchkey;
 	pid_t pid;
 	XImage *icon;
 	Client *next;
@@ -163,12 +164,6 @@ typedef struct {
 	const Arg arg;
 } Key;
 
-typedef struct {
-	unsigned int signum;
-	void (*func)(const Arg *);
-	const Arg arg;
-} Signal;
-
 typedef struct {
 	const char *symbol;
 	void (*arrange)(Monitor *);
@@ -181,13 +176,12 @@ typedef struct {
 	const char *instance;
 	const char *title;
 	unsigned int tags;
-	unsigned int switchtotag;
+	int switchtag;
 	int isfloating;
 	int isterminal;
 	int noswallow;
 	int monitor;
 	const char scratchkey;
-	float floatx, floaty, floatw, floath;
 	int floatborderpx;
 } Rule;
 
@@ -227,14 +221,14 @@ struct Monitor {
 	unsigned int sellt;
 	unsigned int tagset[2];
 	int showbar;
-    int showebar;
+	int showebar;
 	int topbar;
 	Client *clients;
 	Client *sel;
 	Client *stack;
 	Monitor *next;
 	Window barwin;
-    Window ebarwin;
+	Window ebarwin;
 	Window tagwin;
 	Pixmap tagmap[LENGTH(tags)];
 	const Layout *lt[2];
@@ -243,13 +237,14 @@ struct Monitor {
 
 struct Pertag {
 	int ltaxes[LENGTH(tags) + 1][3];
-	unsigned int curtag, prevtag; /* current and previous tag */
-	int nmasters[LENGTH(tags) + 1]; /* number of windows in master area */
-	float mfacts[LENGTH(tags) + 1]; /* mfacts per tag */
-	unsigned int sellts[LENGTH(tags) + 1]; /* selected layouts */
-	const Layout *ltidxs[LENGTH(tags) + 1][2]; /* matrix of tags and layouts indexes  */
-	int showbars[LENGTH(tags) + 1]; /* display bar for the current tag */
-	int showebars[LENGTH(tags) + 1]; /* display ebar for the current tag */
+	unsigned int curtag, prevtag;				/* current and previous tag */
+	int nmasters[LENGTH(tags) + 1];				/* number of windows in master area */
+	float mfacts[LENGTH(tags) + 1];				/* mfacts per tag */
+	unsigned int sellts[LENGTH(tags) + 1];		/* selected layouts */
+	const Layout *ltidxs[LENGTH(tags) + 1][2];	/* matrix of tags and layouts indexes  */
+	int showbars[LENGTH(tags) + 1];				/* display bar for the current tag */
+	int showebars[LENGTH(tags) + 1];			/* display ebar for the current tag */
+	Client *prevzooms[LENGTH(tags) + 1];		/* store zoom information */
 };
 
 /* compile-time check if all tags fit into an unsigned int bit array. */
@@ -260,7 +255,7 @@ void
 applyrules(Client *c)
 {
 	const char *class, *instance;
-	unsigned int i;
+	unsigned int i, newtagset;
 	const Rule *r;
 	Monitor *m;
 	XClassHint ch = { NULL, NULL };
@@ -285,17 +280,26 @@ applyrules(Client *c)
 			c->tags |= r->tags;
 			c->scratchkey = r->scratchkey;
 			c->floatborderpx = r->floatborderpx;
-			c->floatx = r->floatx;
-			c->floaty = r->floaty;
-			c->floatw = r->floatw;
-			c->floath = r->floath;
 			for (m = mons; m && m->num != r->monitor; m = m->next);
 			if (m)
 				c->mon = m;
-			if (r->switchtotag) {
-				Arg a = { .ui = r->tags };
-				c->switchtotag = selmon->tagset[selmon->seltags];
-				view(&a);
+			if (r->switchtag) {
+				selmon = c->mon;
+				if (r->switchtag == 2 || r->switchtag == 4)
+					newtagset = c->mon->tagset[c->mon->seltags] ^ c->tags;
+				else
+					newtagset = c->tags;
+
+				if (newtagset && !(c->tags & c->mon->tagset[c->mon->seltags])) {
+					if (r->switchtag == 3 || r->switchtag == 4)
+						c->switchtag = c->mon->tagset[c->mon->seltags];
+					if (r->switchtag == 1 || r->switchtag == 3)
+						view(&((Arg) { .ui = newtagset }));
+					else {
+						c->mon->tagset[c->mon->seltags] = newtagset;
+						arrange(c->mon);
+					}
+				}
 			}
 		}
 	}
@@ -303,7 +307,6 @@ applyrules(Client *c)
 		XFree(ch.res_class);
 	if (ch.res_name)
 		XFree(ch.res_name);
-
 	c->tags = c->tags & TAGMASK ? c->tags & TAGMASK : c->mon->tagset[c->mon->seltags];
 }
 
@@ -340,7 +343,7 @@ applysizehints(Client *c, int *x, int *y, int *w, int *h, int *bw, int interact)
 		*h = bh;
 	if (*w < bh)
 		*w = bh;
-	if ((resizehints && m->dragon != 1 && m->gappx > resizehintsbm * borderpx)
+	if ((resizehints && m->dragon != 1 && m->gappx > resizehintsbm * borderpx && m ->lt[m->sellt]->arrange != monocle)
 			|| c->isfloating
 			|| !c->mon->lt[c->mon->sellt]->arrange) {
 		/* see last two sentences in ICCCM 4.1.2.3 */
@@ -424,11 +427,11 @@ attachstack(Client *c)
 	c->mon->stack = c;
 }
 
-int
-buttontag(Monitor *m, int x, int xpos, int ypos, int click, Arg *arg)
-{
-	unsigned int columns, i = 0, occ = 0;
+/* buttonpress-functions */
+
+int buttontag(Monitor *m, int x, int xpos, int ypos, int click, Arg *arg) {
 	Client *c;
+	unsigned int columns, i = 0, occ = 0;
 
 	columns = LENGTH(tags) / tagrows + ((LENGTH(tags) % tagrows > 0) ? 1 : 0);
 
@@ -441,19 +444,20 @@ buttontag(Monitor *m, int x, int xpos, int ypos, int click, Arg *arg)
 				continue;
 			x += TEXTW(tags[i]);
 		} while (xpos >= x && ++i < LENGTH(tags));
-	}
-	if(i < LENGTH(tags) && (drawtagmask & DRAWCLASSICTAGS)) {
-		click = ClkTagBar;
-		arg->ui = 1 << i;
-	} else if(xpos < x + columns * bh / tagrows && (drawtagmask & DRAWTAGGRID)) {
+		if(i < LENGTH(tags)) {
+			click = ClkTagBar;
+			arg->ui = 1 << i;
+		}
+	} else if (xpos < x + columns * bh / tagrows && (drawtagmask & DRAWTAGGRID)) {
 		click = ClkTagBar;
 		i = (xpos - x) / (bh / tagrows);
 		i = i + columns * (ypos / (bh / tagrows));
-		if (i >= LENGTH(tags)) {
+		if (i >= LENGTH(tags))
 			i = LENGTH(tags) - 1;
-		}
 		arg->ui = 1 << i;
 	}
+
+
 	return click;
 }
 
@@ -467,7 +471,6 @@ buttonstatus(int l, int xpos, int click)
 		click = ClkNotifyText;
  		return click;
 	}
-
 	dwmblockssig = -1;
 	while (text[++i]) {
 		if ((unsigned char)text[i] < ' ') {
@@ -510,13 +513,13 @@ buttonpress(XEvent *e)
 		len = sizeof(barorder)/sizeof(barorder[0]);
 
 		for (i = 0; set == 0 && i < len && i >= 0; pos == 1 ? i++ : i--) {
-			if (strcmp ("tabgroups", barorder[i]) == 0) {
+			if (strcmp ("bartab", barorder[i]) == 0) {
 				if (pos == 1) {pos = -1; i = len - 1; l = lr; lr = r; }
 				else {r = lr; break;}
 			}
 			if (strcmp ("tagbar", barorder[i]) == 0) {
-				if (pos * ev->x < pos * (lr + pos * tw)) {click = buttontag(m, lr - (pos < 0 ? tw : 0), ev->x, ev->y, click, &arg); set = 1; }
-				else lr = lr + pos * tw;
+				if (pos * ev->x < pos * (lr + pos * tgw)) {click = buttontag(m, lr - (pos < 0 ? tgw : 0), ev->x, ev->y, click, &arg); set = 1; }
+				else lr = lr + pos * tgw;
 			} else if (strcmp ("ltsymbol", barorder[i]) == 0) {
 				if (pos * ev->x < pos * (lr + pos * blw)) { click = ClkLtSymbol; set = 1; }
 				else lr = lr + pos * blw;
@@ -535,7 +538,7 @@ buttonpress(XEvent *e)
 			}
 		}
 		if (set == 0 && ev->x > l && ev->x < r)
-			drawbartabgroups(m, l, m->ww - r, 0, ev->x);
+			drawtabgroups(m, l, m->ww - r, 0, ev->x);
 
 	} else if (ev->window == selmon->ebarwin) {
 		len = sizeof(ebarorder)/sizeof(ebarorder[0]);
@@ -545,8 +548,8 @@ buttonpress(XEvent *e)
 				else {r = lr; break;}
 			}
 			if (strcmp ("tagbar", ebarorder[i]) == 0) {
-				if (pos * ev->x < pos * (lr + pos * tw)) {click = buttontag(m, lr - (pos < 0 ? tw : 0), ev->x, ev->y, click, &arg); set = 1; }
-				else lr = lr + pos * tw;
+				if (pos * ev->x < pos * (lr + pos * tgw)) {click = buttontag(m, lr - (pos < 0 ? tgw : 0), ev->x, ev->y, click, &arg); set = 1; }
+				else lr = lr + pos * tgw;
 			} else if (strcmp ("ltsymbol", ebarorder[i]) == 0) {
 				if (pos * ev->x < pos * (lr + pos * blw)) { click = ClkLtSymbol; set = 1; }
 				else lr = lr + pos * blw;
@@ -608,15 +611,13 @@ cleanup(void)
 	XUngrabKey(dpy, AnyKey, AnyModifier, root);
 	XUnmapWindow(dpy, m->ebarwin);
 	XDestroyWindow(dpy, m->ebarwin);
-    while (mons)
+	while (mons)
 		cleanupmon(mons);
-	if (showsystray && systray) {
+	if (showsystray) {
 		while (systray->icons)
 			removesystrayicon(systray->icons);
-		if (systray->win) {
-			XUnmapWindow(dpy, systray->win);
-			XDestroyWindow(dpy, systray->win);
-		}
+		XUnmapWindow(dpy, systray->win);
+		XDestroyWindow(dpy, systray->win);
 		free(systray);
 	}
 	for (i = 0; i < CurLast; i++)
@@ -706,7 +707,6 @@ clientmessage(XEvent *e)
 				drawebar(rawstext, selmon, 0);
 			else
 				drawbar(selmon, 0);
-			updatesystray();
 		}
 		return;
 	}
@@ -717,7 +717,7 @@ clientmessage(XEvent *e)
 		if (cme->data.l[1] == netatom[NetWMFullscreen]
 		|| cme->data.l[2] == netatom[NetWMFullscreen])
 			setfullscreen(c, (cme->data.l[0] == 1 /* _NET_WM_STATE_ADD    */
-				|| cme->data.l[0] == 2 /* _NET_WM_STATE_TOGGLE */));
+				|| (cme->data.l[0] == 2 /* _NET_WM_STATE_TOGGLE */ && !c->isfullscreen)));
 	} else if (cme->message_type == netatom[NetActiveWindow]) {
 		if (c != selmon->sel && !c->isurgent)
 			seturgent(c, 1);
@@ -747,6 +747,7 @@ void
 configurenotify(XEvent *e)
 {
 	Monitor *m;
+	Client *c;
 	XConfigureEvent *ev = &e->xconfigure;
 	int dirty;
 
@@ -759,6 +760,9 @@ configurenotify(XEvent *e)
 			drw_resize(drw, sw, bh);
 			updatebars();
 			for (m = mons; m; m = m->next) {
+				for (c = m->clients; c; c = c->next)
+					if (c->isfullscreen)
+						resizeclient(c, m->mx, m->my, m->mw, m->mh, 0);
 				XMoveResizeWindow(dpy, m->barwin, m->wx + (bargap ? m->gappx : 0), m->by, m->ww - (bargap ? 2 * m->gappx : 0), bh);
 				XMoveResizeWindow(dpy, m->ebarwin, m->wx + (bargap ? m->gappx : 0), m->eby, m->ww - (bargap ? 2 * m->gappx : 0), bh);
 			}
@@ -780,7 +784,6 @@ configurerequest(XEvent *e)
 		if (ev->value_mask & CWBorderWidth)
 			c->bw = ev->border_width;
 		else if (c->isfloating || !selmon->lt[selmon->sellt]->arrange) {
-
 			m = c->mon;
 			if (!c->ignorecfgreqpos) {
 				if (ev->value_mask & CWX) {
@@ -836,7 +839,7 @@ createmon(void)
 	m->mfact = mfact;
 	m->nmaster = nmaster;
 	m->showbar = showbar;
-    m->showebar = showebar;
+	m->showebar = showebar;
 	m->topbar = topbar;
 	m->gappx = gappx;
 	m->dragon = dragon;
@@ -860,26 +863,11 @@ createmon(void)
 		m->pertag->sellts[i] = m->sellt;
 		m->pertag->showbars[i] = m->showbar;
 		m->pertag->showebars[i] = m->showebar;
+		m->pertag->prevzooms[i] = NULL;
 	}
 	return m;
 }
 
-void
-demoncleaner(const Arg *arg)
-{
-	/* Clear status bar to avoid artifacts beneath systray icons */
-	drawtheme(0,0,0,0);
-	drw_rect(drw, 0, 0, selmon->ww, bh, 1, 1);
-	drw_map(drw, esys ? selmon->ebarwin : selmon->barwin, 0, 0, selmon->ww, bh);
-
-	toggleebar(0);
-	togglebar(0);
-	arrange(selmon);
-	togglebar(0);
-	toggleebar(0);
-	arrange(selmon);
-}
-
 void
 destroynotify(XEvent *e)
 {
@@ -890,9 +878,11 @@ destroynotify(XEvent *e)
 		unmanage(c, 1);
 	else if (showsystray && (c = wintosystrayicon(ev->window))) {
 		removesystrayicon(c);
-		updatesystray();
-	}
-	else if ((c = swallowingclient(ev->window)))
+		if (esys)
+			drawebar(rawstext, selmon, 0);
+		else
+			drawbar(selmon, 0);
+	} else if ((c = swallowingclient(ev->window)))
 		unmanage(c->swallowing, 1);
 }
 
@@ -934,58 +924,58 @@ dirtomon(int dir)
 	return m;
 }
 
-int
-drawtag(Monitor *m, int lr, int p, int xpos) {
-	tw = lr;
-	Client *c;
-	int i, indn, x, w = 0;
+/* drawbar-functions */
+
+int drawtag(Monitor *m, int lr, int p, int xpos) {
+	tgw = lr;
+	int indn, i, x, w = 0;
 	unsigned int occ = 0, urg = 0, prev = 0;
+	Client *c;
 
 	for (c = m->clients; c; c = c->next) {
 		occ |= c->tags == 255 ? 0 : c->tags;
 		if (c->isurgent)
 			urg |= c->tags;
 	}
-	if (drawtagmask & DRAWCLASSICTAGS)
-	for (i = p ? LENGTH(tags) - 1 : 0; p ? i >= 0 : i < LENGTH(tags); p ? i-- : i++) {
-		/* do not draw vacant tags */
-		if (!(occ & 1 << i || m->tagset[m->seltags] & 1 << i))
-		continue;
-
-		indn = 0;
-		w = TEXTW(tags[i]);
-		x = p ? m->ww - lr - w : lr;
-
-		if (xpos && xpos >= x && xpos <= x + w) {
-			esep = x;
-			eblock = w;
-		}
-		if (m->tagset[m->seltags] & 1 << i)
-			drawtheme(0,0,3,tagtheme);
-		else if (x == esep && w == eblock && w) {
-			drawtheme(0,0,2,tagtheme);
-			prev = 1;
-			showtagpreview(i);
-		} else
-			drawtheme(0,0,1,tagtheme);
-
-		drw_text(drw, x, (bartheme && m->tagset[m->seltags] & 1 << i) ? 0 : x != esep || w != eblock ? -1 : 0, w, bh, lrpad / 2, tags[i], urg & 1 << i);
+	if (drawtagmask & DRAWCLASSICTAGS) {
+		for (i = p ? LENGTH(tags) - 1 : 0; p ? i >= 0 : i < LENGTH(tags); p ? i-- : i++) {
+			/* do not draw vacant tags */
+			if (!(occ & 1 << i || m->tagset[m->seltags] & 1 << i))
+				continue;
+			indn = 0;
+			w = TEXTW(tags[i]);
+			x = p ? m->ww - lr - w : lr;
 
-		if (bartheme) {
-			if(m->tagset[m->seltags] & 1 << i)
-				drawtheme(x, w, 3, tagtheme);
-			else if (x != esep || w != eblock)
-				drawtheme(x, w, 1, tagtheme);
-			else
-				drawtheme(x, w, 2, tagtheme);
-		}
-		for (c = m->clients; c; c = c->next) {
-			if ((c->tags & (1 << i)) && (indn * 3 + 2 < bh)) {
-				drw_rect(drw, x + ((bartheme > 0 && tagtheme > 1) ? 2 : 1), indn * 3 + 1 + ((bartheme && m->tagset[m->seltags] & 1 << i) ? 1 : x != esep || w != eblock ? 0 : 1), selmon->sel == c ? 5 : 2, 2, 1, urg & 1 << i);
-				indn++;
+			if (xpos && xpos >= x && xpos <= x + w) {
+				fsep = x;
+				fblock = w;
+			}
+			if (m->tagset[m->seltags] & 1 << i)
+				drawtheme(0,0,3,tagtheme);
+			else if (x == fsep && w == fblock && w) {
+				drawtheme(0,0,2,tagtheme);
+				prev = 1;
+				showtagpreview(i);
+			} else
+				drawtheme(0,0,1,tagtheme);
+			int yy = ((m->tagset[m->seltags] & 1 << i) || (x == fsep && w == fblock)) ? 0 : (bartheme && tagtheme) ? -1 : 0;
+			drw_text(drw, x, yy, w, bh, lrpad / 2, tags[i], urg & 1 << i);
+			if (bartheme) {
+				if(m->tagset[m->seltags] & 1 << i)
+					drawtheme(x, w, 3, tagtheme);
+				else if (x != fsep || w != fblock)
+					drawtheme(x, w, 1, tagtheme);
+				else
+					drawtheme(x, w, 2, tagtheme);
 			}
+			for (c = m->clients; c; c = c->next) {
+				if ((c->tags & (1 << i)) && (indn * 3 + 2 < bh)) {
+					drw_rect(drw, x + ((bartheme > 0 && tagtheme > 1) ? 2 : 1), indn * 3 + 2 + yy, selmon->sel == c ? 5 : 2, 2, 1, urg & 1 << i);
+					indn++;
+				}
+			}
+			lr = lr + w;
 		}
-		lr = lr + w;
 	}
 	if (prev == 0)
 		XUnmapWindow(dpy, selmon->tagwin);
@@ -994,77 +984,30 @@ drawtag(Monitor *m, int lr, int p, int xpos) {
 		w = bh / tagrows * (LENGTH(tags) / tagrows + ((LENGTH(tags) % tagrows > 0) ? 1 : 0));
 		x = p ? m->ww - lr - w : lr;
 		if (xpos && xpos >= x && xpos <= x + w) {
-			esep = x;
-			eblock = w;
+			fsep = x;
+			fblock = w;
 		}
 		drawtaggrid(m,&x,occ);
 		lr = lr + w;
 	}
-	tw = lr - tw;
+	tgw = lr - tgw;
 	return lr;
 }
 
-int
-drawltsymbol(Monitor *m, int lr, int p, int xpos) {
-	blw = TEXTW(m->ltsymbol);
-	int x = p ? m->ww - blw - lr : lr;
-
-	if (xpos && xpos >= x && xpos <= x + blw) {
-		esep = x;
-		eblock = blw;
-	}
-	if (x == esep && blw == eblock && blw)
-		drawtheme(0,0,2,tagtheme);
-	else
-		drawtheme(0,0,0,0);
-	drw_text(drw, x, 0, blw, bh, lrpad / 2, m->ltsymbol, 0);
-
-	return lr + blw;
-}
-
-int
-drawsep(Monitor *m, int lr, int p, int xpos, int s) {
-	char sepsymbol[16];
-	char sym = 124;
-	int sep = 0;
-
-	snprintf(sepsymbol, sizeof sepsymbol, "%c", sym);
-	if (s == 3)
-		sep = lsep = TEXTW(sepsymbol);
-	else if (s == 2)
-		sep = msep = TEXTW(sepsymbol) - lrpad;
-	else if (s == 1)
-		sep = ssep = lrpad/2;
-	int x = p ? m->ww - sep - lr : lr;
-
-	if (xpos && xpos >= x && xpos <= x + sep) {
-		esep = x;
-		eblock = sep;
-	}
-	drawtheme(0,0,0,bartheme);
-	drw_text(drw, x, 0, sep, bh, s == 3 ? lrpad / 2 : 0, s != 1 ? sepsymbol : "", 0);
-
-	return lr + sep;
-}
-
-int
-drawsystray(Monitor *m, int lr, int p, int xpos) {
+int drawsystray(Monitor *m, int lr, int p, int xpos) {
 	stw = 0;
-	if (showsystray && m == systraytomon(m))
+	if (showsystray && m == systraytomon(m)) {
 		stw = getsystraywidth();
-	int x = p ? m->ww - stw - lr : lr;
-	xsys = x + stw + (bargap ? selmon->gappx : 0);
-
-	if (xpos && xpos >= x && xpos <= x + stw) {
-		esep = x;
-		eblock = stw;
-	}
-	if (showsystray) {
+		int x = p ? m->ww - stw - lr : lr;
+		xsys = x + stw + (bargap ? selmon->gappx : 0);
+	
+		if (xpos && xpos >= x && xpos <= x + stw) {
+			fsep = x;
+			fblock = stw;
+		}
 		/* Clear status bar to avoid artifacts beneath systray icons */
-		drw_setscheme(drw, scheme[LENGTH(colors)]);
-		drw->scheme[ColBg] = scheme[SchemeBar][bartheme ? ColFloat : ColBg];
+		drawtheme(0,0,0,0);
 		drw_rect(drw, x, 0, stw, bh, 1, 1);
-		drw_map(drw, esys ? m->ebarwin : m->barwin, x, 0, stw, bh);
 
 		updatesystray();
 	}
@@ -1095,8 +1038,8 @@ drawstatus(char* stext, Monitor *m, int xpos, int l, int r)
 		xstat = (selmon->ww - l - r - status2dtextlength(stext)) / 2;
 		x = sep += xstat;
 		if (xpos > l && xpos < x) {
-			esep = l;
-			eblock = x - l;
+			fsep = l;
+			fblock = x - l;
 		}
 	}
 
@@ -1111,12 +1054,12 @@ drawstatus(char* stext, Monitor *m, int xpos, int l, int r)
 				blocktext[i] = '\0';
 			block = status2dtextlength(stext);
 			if (xpos && xpos >= sep && xpos <= sep + block) {
-				esep = sep;
-				eblock = block;
+				fsep = sep;
+				fblock = block;
 			}
 			if (istatustimer)
 				drawtheme(0,0,0,0);
-			else if (sep == esep && block == eblock && block)
+			else if (sep == fsep && block == fblock && block)
 				drawtheme(0,0,2,statustheme);
 			else
 				drawtheme(0,0,1,statustheme);
@@ -1133,7 +1076,7 @@ drawstatus(char* stext, Monitor *m, int xpos, int l, int r)
 					w = TEXTW(text) - lrpad;
 					if (x + w >= selmon->ww - r)
 						return;
-					drw_text(drw, x, (bartheme && !istatustimer) ? sep != esep || block != eblock ? -1 : 0 : 0, w, bh, 0, text, 0);
+					drw_text(drw, x, (bartheme && !istatustimer) ? sep != fsep || block != fblock ? -1 : 0 : 0, w, bh, 0, text, 0);
 					x += w;
 					/* process code */
 					while (text[++i] != '^') {
@@ -1162,7 +1105,7 @@ drawstatus(char* stext, Monitor *m, int xpos, int l, int r)
 						} else if (text[i] == 'd') {
 							if (istatustimer)
 								drawtheme(0,0,0,0);
-							else if (sep == esep && block == eblock && block)
+							else if (sep == fsep && block == fblock && block)
 								drawtheme(0,0,2,statustheme);
 							else
 								drawtheme(0,0,1,statustheme);
@@ -1195,13 +1138,13 @@ drawstatus(char* stext, Monitor *m, int xpos, int l, int r)
 				w = TEXTW(text) - lrpad;
 				if (x + w >= selmon->ww - r)
 					return;
-				drw_text(drw, x, (bartheme && !istatustimer) ? sep != esep || block != eblock ? -1 : 0 : 0, w, bh, 0, text, 0);
+				drw_text(drw, x, (bartheme && !istatustimer) ? sep != fsep || block != fblock ? -1 : 0 : 0, w, bh, 0, text, 0);
 				x += w;
 			}
 			i = -1;
 
 			if (bartheme && block > 0 && !istatustimer) {
-				if (sep != esep || block != eblock)
+				if (sep != fsep || block != fblock)
 					drawtheme(sep, block, 1, statustheme);
 				else
 					drawtheme(sep, block, 2, statustheme);
@@ -1214,8 +1157,8 @@ drawstatus(char* stext, Monitor *m, int xpos, int l, int r)
 		}
 	}
 	if (xpos && xpos > sep + block && xpos < selmon->ww - r) {
-		esep = sep + block;
-		eblock = selmon->ww - sep - block - r;
+		fsep = sep + block;
+		fblock = selmon->ww - sep - block - r;
 	}
 
 	drawtheme(0,0,0,0);
@@ -1224,6 +1167,47 @@ drawstatus(char* stext, Monitor *m, int xpos, int l, int r)
 	free(p);
 }
 
+int drawsep(Monitor *m, int lr, int p, int xpos, int s) {
+	char sepsymbol[16];
+	char sym = 124;
+	int sep = 0;
+
+	snprintf(sepsymbol, sizeof sepsymbol, "%c", sym);
+	if (s == 3)
+		sep = lsep = TEXTW(sepsymbol);
+	else if (s == 2)
+		sep = msep = TEXTW(sepsymbol) - lrpad;
+	else if (s == 1)
+		sep = ssep = lrpad/2;
+	int x = p ? m->ww - sep - lr : lr;
+
+	if (xpos && xpos >= x && xpos <= x + sep) {
+		fsep = x;
+		fblock = sep;
+	}
+	drawtheme(0,0,0,bartheme);
+	drw_text(drw, x, 0, sep, bh, s == 3 ? lrpad / 2 : 0, s != 1 ? sepsymbol : "", 0);
+
+	return lr + sep;
+}
+
+int drawltsymbol(Monitor *m, int lr, int p, int xpos) {
+	blw = TEXTW(m->ltsymbol);
+	int x = p ? m->ww - blw - lr : lr;
+
+	if (xpos && xpos >= x && xpos <= x + blw) {
+		fsep = x;
+		fblock = blw;
+	}
+	if (x == fsep && blw == fblock && blw)
+		drawtheme(0,0,2,tagtheme);
+	else
+		drawtheme(0,0,0,0);
+	drw_text(drw, x, 0, blw, bh, lrpad / 2, m->ltsymbol, 0);
+
+	return lr + blw;
+}
+
 void
 drawbar(Monitor *m, int xpos)
 {
@@ -1232,7 +1216,7 @@ drawbar(Monitor *m, int xpos)
 	len = sizeof(barorder)/sizeof(barorder[0]);
 
 	for (i = 0; i < len && i >= 0; pos == 1 ? i-- : i++) {
-		if (strcmp ("tabgroups", barorder[i]) == 0) {
+		if (strcmp ("bartab", barorder[i]) == 0) {
 			if (pos == 0) {pos = 1; i = len - 1; l = lr; lr = bargap ? 2 * selmon->gappx : 0; }
 			else {r = lr; break;}
 		}
@@ -1243,13 +1227,13 @@ drawbar(Monitor *m, int xpos)
 		if (strcmp ("systray", barorder[i]) == 0)
 			lr = drawsystray(m, lr, pos, xpos);
 		if (strcmp ("largesep", barorder[i]) == 0)
-			lr = drawsep(m, lr, pos, xpos, 3);
+			lr = drawsep(m, lr, pos, 3, xpos);
 		if (strcmp ("midsep", barorder[i]) == 0)
-			lr = drawsep(m, lr, pos, xpos, 2);
+			lr = drawsep(m, lr, pos, 2, xpos);
 		if (strcmp ("shortsep", barorder[i]) == 0)
-			lr = drawsep(m, lr, pos, xpos, 1);
+			lr = drawsep(m, lr, pos, 1, xpos);
 	}
-	drawbartabgroups(m, l, r, xpos, 0);
+	drawtabgroups(m, l, r, xpos, 0);
 	drw_map(drw, m->barwin, 0, 0, m->ww, bh);
 }
 
@@ -1269,7 +1253,7 @@ drawebar(char* stext, Monitor *m, int xpos)
 			lr = drawtag(m, lr, pos, xpos);
 		if (strcmp ("ltsymbol", ebarorder[i]) == 0)
 			lr = drawltsymbol(m, lr, pos, xpos);
-		if (strcmp ("systray", ebarorder[i]) == 0)
+		if (strcmp ("systray", barorder[i]) == 0)
 			lr = drawsystray(m, lr, pos, xpos);
 		if (strcmp ("largesep", ebarorder[i]) == 0)
 			lr = drawsep(m, lr, pos, xpos, 3);
@@ -1300,7 +1284,7 @@ enternotify(XEvent *e)
 	Monitor *m;
 	XCrossingEvent *ev = &e->xcrossing;
 
-	eblock = esep = 0;
+	fblock = fsep = 0;
 	if (ev->window == selmon->barwin)
 		drawebar(rawstext, selmon, 0);
 	else if (ev->window == selmon->ebarwin)
@@ -1333,8 +1317,6 @@ expose(XEvent *e)
 	if (ev->count == 0 && (m = wintomon(ev->window))) {
 		drawbar(m, 0);
 		drawebar(rawstext, m, 0);
-		if (showsystray && m == selmon)
-			updatesystray();
 	}
 }
 
@@ -1361,9 +1343,7 @@ focus(Client *c)
 		XDeleteProperty(dpy, root, netatom[NetActiveWindow]);
 	}
 	selmon->sel = c;
-	if (selmon->lt[selmon->sellt]->arrange == tile)
-		arrangemon(selmon);
-	if (selmon->lt[selmon->sellt]->arrange == monocle)
+	if (selmon->lt[selmon->sellt]->arrange == tile || selmon->lt[selmon->sellt]->arrange == monocle)
 		arrangemon(selmon);
 	drawbars();
 }
@@ -1397,7 +1377,7 @@ focusstack(const Arg *arg)
 {
 	Client *c = NULL, *i;
 
-	if (!selmon->sel)
+	if (!selmon->sel || (selmon->sel->isfullscreen && lockfullscreen))
 		return;
 	if (arg->i > 0) {
 		for (c = selmon->sel->next; c && !ISVISIBLE(c); c = c->next);
@@ -1470,79 +1450,6 @@ getstate(Window w)
 	return result;
 }
 
-XImage *
-geticonprop(Window win)
-{
-	int format, iconsize;
-	unsigned long n, extra, *p = NULL;
-	Atom real;
-
-	iconsize = bh - 2 * iconpad;
-
-	if (XGetWindowProperty(dpy, win, netatom[NetWMIcon], 0L, LONG_MAX, False, AnyPropertyType,
-						   &real, &format, &n, &extra, (unsigned char **)&p) != Success)
-		return NULL;
-	if (n == 0 || format != 32) { XFree(p); return NULL; }
-
-	unsigned long *bstp = NULL;
-	uint32_t w, h, sz;
-
-	{
-		const unsigned long *end = p + n;
-		unsigned long *i;
-		uint32_t bstd = UINT32_MAX, d, m;
-		for (i = p; i < end - 1; i += sz) {
-			if ((w = *i++) > UINT16_MAX || (h = *i++) > UINT16_MAX) { XFree(p); return NULL; }
-			if ((sz = w * h) > end - i) break;
-			if ((m = w > h ? w : h) >= iconsize && (d = m - iconsize) < bstd) { bstd = d; bstp = i; }
-		}
-		if (!bstp) {
-			for (i = p; i < end - 1; i += sz) {
-				if ((w = *i++) > UINT16_MAX || (h = *i++) > UINT16_MAX) { XFree(p); return NULL; }
-				if ((sz = w * h) > end - i) break;
-				if ((d = iconsize - (w > h ? w : h)) < bstd) { bstd = d; bstp = i; }
-			}
-		}
-		if (!bstp) { XFree(p); return NULL; }
-	}
-
-	if ((w = *(bstp - 2)) == 0 || (h = *(bstp - 1)) == 0) { XFree(p); return NULL; }
-
-	uint32_t icw, ich, icsz;
-	if (w <= h) {
-		ich = iconsize; icw = w * iconsize / h;
-		if (icw == 0) icw = 1;
-	}
-	else {
-		icw = iconsize; ich = h * iconsize / w;
-		if (ich == 0) ich = 1;
-	}
-	icsz = icw * ich;
-
-	uint32_t i;
-#if ULONG_MAX > UINT32_MAX
-	uint32_t *bstp32 = (uint32_t *)bstp;
-	for (sz = w * h, i = 0; i < sz; ++i) bstp32[i] = bstp[i];
-#endif
-	uint32_t *icbuf = malloc(icsz << 2); if(!icbuf) { XFree(p); return NULL; }
-	if (w == icw && h == ich) memcpy(icbuf, bstp, icsz << 2);
-	else {
-		Imlib_Image origin = imlib_create_image_using_data(w, h, (DATA32 *)bstp);
-		if (!origin) { XFree(p); free(icbuf); return NULL; }
-		imlib_context_set_image(origin);
-		imlib_image_set_has_alpha(1);
-		Imlib_Image scaled = imlib_create_cropped_scaled_image(0, 0, w, h, icw, ich);
-		imlib_free_image_and_decache();
-		if (!scaled) { XFree(p); free(icbuf); return NULL; }
-		imlib_context_set_image(scaled);
-		imlib_image_set_has_alpha(1);
-		memcpy(icbuf, imlib_image_get_data_for_reading_only(), icsz << 2);
-		imlib_free_image_and_decache();
-	}
-	XFree(p);
-	return XCreateImage(drw->dpy, drw->visual, drw->depth, ZPixmap, 0, (char *)icbuf, icw, ich, 32, 0);
-}
-
 int
 gettextprop(Window w, Atom atom, char *text, unsigned int size)
 {
@@ -1648,47 +1555,6 @@ keypress(XEvent *e)
 			keys[i].func(&(keys[i].arg));
 }
 
-int
-fake_signal(void)
-{
-	char fsignal[256];
-	char indicator[9] = "fsignal:";
-	char str_signum[16];
-	int i, v, signum;
-	size_t len_fsignal, len_indicator = strlen(indicator);
-
-	// Get root name property
-	if (gettextprop(root, XA_WM_NAME, fsignal, sizeof(fsignal))) {
-		len_fsignal = strlen(fsignal);
-
-		// Check if this is indeed a fake signal
-		if (len_indicator > len_fsignal ? 0 : strncmp(indicator, fsignal, len_indicator) == 0) {
-			memcpy(str_signum, &fsignal[len_indicator], len_fsignal - len_indicator);
-			str_signum[len_fsignal - len_indicator] = '\0';
-
-			// Convert string value into managable integer
-			for (i = signum = 0; i < strlen(str_signum); i++) {
-				v = str_signum[i] - '0';
-				if (v >= 0 && v <= 9) {
-					signum = signum * 10 + v;
-				}
-			}
-
-			// Check if a signal was found, and if so handle it
-			if (signum)
-				for (i = 0; i < LENGTH(signals); i++)
-					if (signum == signals[i].signum && signals[i].func)
-						signals[i].func(&(signals[i].arg));
-
-			// A fake signal was sent
-			return 1;
-		}
-	}
-
-	// No fake signal was sent, so proceed with update
-	return 0;
-}
-
 void
 killclient(const Arg *arg)
 {
@@ -1718,7 +1584,6 @@ manage(Window w, XWindowAttributes *wa)
 	c->pid = winpid(w);
 	/* geometry */
 	c->floatborderpx = -1;
-	c->floatx = c->floaty = c->floatw = c->floath = -10;
 	c->x = c->oldx = wa->x;
 	c->y = c->oldy = wa->y;
 	c->w = c->oldw = wa->width;
@@ -1739,75 +1604,22 @@ manage(Window w, XWindowAttributes *wa)
 		term = termforwin(c);
 	}
 
-	if (c->x + WIDTH(c) + 2 * borderpx > c->mon->wx + c->mon->ww)
-		c->x = c->mon->wx + c->mon->ww - WIDTH(c) - 2 * borderpx;
-	if (c->y + HEIGHT(c) + 2 * borderpx > c->mon->wy + c->mon->wh)
-		c->y = c->mon->wy + c->mon->wh - HEIGHT(c) - 2 * borderpx;
-	c->x = MAX(c->x, c->mon->wx);
-	c->y = MAX(c->y, c->mon->wy);
-	if (c->h > c->mon->wh - 2 * borderpx)
-		c->h = c->mon->wh - 2 * borderpx;
-	if (c->w > c->mon->ww - 2 * borderpx)
-		c->w = c->mon->ww - 2 * borderpx;
-	if (c->y < c->mon->wy)
-		c->y = c->mon->wy;
+	if (c->x + WIDTH(c) > c->mon->mx + c->mon->mw)
+		c->x = c->mon->mx + c->mon->mw - WIDTH(c);
+	if (c->y + HEIGHT(c) > c->mon->my + c->mon->mh)
+		c->y = c->mon->my + c->mon->mh - HEIGHT(c);
+	c->x = MAX(c->x, c->mon->mx);
+	/* only fix client y-offset, if the client center might cover the bar */
+	c->y = MAX(c->y, ((c->mon->by == c->mon->my) && (c->x + (c->w / 2) >= c->mon->wx)
+		&& (c->x + (c->w / 2) < c->mon->wx + c->mon->ww)) ? bh : c->mon->my);
 	c->bw = borderpx;
 
-	/* float-dimensions setup */
 	if (c->isfloating && c->floatborderpx >= 0)
 		wc.border_width = c->floatborderpx;
 	else
 		wc.border_width = c->bw;
-
-	if (c->floatx == 0 || c->floatx >= 1)
-		c->x = c->floatx;
-	else if (fabs(c->floatx) > 0 && fabs(c->floatx) < 1)
-		c->x = round(c->mon->mw * 10 / 8 * (fabs(c->floatx) - 0.1) + (bargap ? c->mon->gappx : 0));
-
-	if (c->floaty == 0 || c->floaty >= 1)
-		c->y = c->floaty;
-	else if (c->floaty > 0 && c->floaty < 1)
-		c->y = round(c->mon->wy + (c->floaty - 0.1) * c->mon->wh * 10 / 8);
-	else if (c->floaty < 0 && c->floaty > -1)
-		c->y = round(c->mon->wh * 10 / 8 * (fabs(c->floaty) - 0.1) + (bargap ? c->mon->gappx : 0));
-
-	if (c->floatw > bh)
-		c->w = c->floatw;
-	else if (fabs(c->floatw) > 0 && fabs(c->floatw) < 1)
-		c->w = round(c->mon->mw * 10 / 8 * (fabs(c->floatw) - 0.1) - ((c->floatx == 0 || c->floatx >= 1) ? 0 : (bargap ? c->mon->gappx : 0)) - c->x);
-	if (c->floath > bh)
-		c->h = c->floath;
-	else if (fabs(c->floath) > 0 && fabs(c->floath) < 1) {
-		if (c->floaty == 0 || c->floaty >= 1)
-			c->h = round(c->mon->mh * 10 / 8 * (fabs(c->floath) - 0.1) - c->y);
-		if (c->floaty < 0 && c->floaty > -1)
-			c->h = round(c->mon->mh * 10 / 8 * (fabs(c->floath) - 0.1) - (bargap ? c->mon->gappx : 0) - c->y);
-		else
-			c->h = round(c->mon->wh * 10 / 8 * (fabs(c->floath) - 0.1) - c->y);
-	}
-	if (c->floatx == -1)
-		c->x = round((c->mon->mw - c->w) / 2);
-	if (c->floaty == -1)
-		c->y = round(c->mon->wy + (c->mon->wh - c->h) / 2);
-	if (c->floatx == -2) {	/* this is ugly */
-		c->x =	((int)(xbutt - c->w / 2) < (bargap ? c->mon->gappx : 0))
-					? (bargap ? c->mon->gappx : 0) :
-				((int)(xbutt + c->w / 2) > c->mon->mw - (bargap ? c->mon->gappx : 0))
-					? c->mon->mw - c->w - 2 * wc.border_width - (bargap ? c->mon->gappx : 0)
-				: (xbutt - c->w / 2);
-	}
-	if (c->floaty == -2)
-		c->y = ybutt + bh;
-
 	XConfigureWindow(dpy, w, CWBorderWidth, &wc);
-	if(c->isfloating)
-		XSetWindowBorder(dpy, w, scheme[SchemeBorder][ColFloat].pixel);
-	else {
-		if ( selmon->gappx > 2 * borderpx)
-			XSetWindowBorder(dpy, w, scheme[SchemeBorder][ColBg].pixel);
-		else
-			XSetWindowBorder(dpy, w, scheme[SchemeBorder][ColBorder].pixel);
-	}
+	XSetWindowBorder(dpy, w, scheme[SchemeBorder][c->isfloating ? ColFloat : (selmon->gappx > 2 * borderpx) ? ColBg : ColBorder].pixel);
 	configure(c); /* propagates border_width, if size doesn't change */
 	updatewindowtype(c);
 	updatesizehints(c);
@@ -1856,7 +1668,6 @@ manage(Window w, XWindowAttributes *wa)
 			c->mon->sel->snext = c;
 		}
 	}
-
 	XChangeProperty(dpy, root, netatom[NetClientList], XA_WINDOW, 32, PropModeAppend,
 		(unsigned char *) &(c->win), 1);
 	XMoveResizeWindow(dpy, c->win, c->x + 2 * sw, c->y, c->w, c->h); /* some windows require this */
@@ -1877,7 +1688,6 @@ manage(Window w, XWindowAttributes *wa)
 			}
 		}
 	}
-
 	arrange(c->mon);
 	XMapWindow(dpy, c->win);
 	if (focusclient)
@@ -1903,7 +1713,10 @@ maprequest(XEvent *e)
 	Client *i;
 	if (showsystray && (i = wintosystrayicon(ev->window))) {
 		sendevent(i->win, netatom[Xembed], StructureNotifyMask, CurrentTime, XEMBED_WINDOW_ACTIVATE, 0, systray->win, XEMBED_EMBEDDED_VERSION);
-		updatesystray();
+		if (esys)
+			drawebar(rawstext, selmon, 0);
+		else
+			drawbar(selmon, 0);
 	}
 
 	if (!XGetWindowAttributes(dpy, ev->window, &wa))
@@ -1927,13 +1740,13 @@ monocle(Monitor *m)
 		snprintf(m->ltsymbol, sizeof m->ltsymbol, "[%d]", n);
 	for (c = m->stack; c && (!ISVISIBLE(c) || c->isfloating); c = c->snext);
 	if (c && !c->isfloating) {
-		XMoveWindow(dpy, c->win, m->wx + m->gappx, m->wy + m->gappx);
-		resize(c, m->wx + m->gappx, m->wy + m->gappx, m->ww - 2 * m->gappx, m->wh - 2 * m->gappx, 0, 0);
+		XMoveWindow(dpy, c->win, m->wx + m->gappx - c->bw, m->wy + m->gappx - (abs(m->showbar) == 0 ? c->bw : 0));
+		resize(c, m->wx + m->gappx - c->bw, m->wy + m->gappx - (abs(m->showbar) == 0 ? c->bw : 0), m->ww - 2 * m->gappx, m->wh - 2 * m->gappx, 0, 0);
 		c = c->snext;
 	}
 	for (; c; c = c->snext)
 		if (!c->isfloating && ISVISIBLE(c))
-			XMoveWindow(dpy, c->win, WIDTH(c) * -2, c->y);
+			XMoveWindow(dpy, c->win, - 2 * WIDTH(c), c->y);
 }
 
 void
@@ -1944,8 +1757,8 @@ motionnotify(XEvent *e)
 	XMotionEvent *ev = &e->xmotion;
 
 	if (ev->window == selmon->ebarwin || ev->window == selmon->barwin) {
-		if (ev->x < esep || ev->x > esep + eblock) {
-			eblock = esep = 0;
+		if (ev->x < fsep || ev->x > fsep + fblock) {
+			fblock = fsep = 0;
 			if (ev->window == selmon->ebarwin)
 				drawebar(rawstext, selmon, ev->x);
 			else
@@ -1975,6 +1788,8 @@ movemouse(const Arg *arg)
 
 	if (!(c = selmon->sel))
 		return;
+	if (c->isfullscreen) /* no support moving fullscreen windows by mouse */
+		return;
 	restack(selmon);
 	ocx = c->x;
 	ocy = c->y;
@@ -1993,188 +1808,32 @@ movemouse(const Arg *arg)
 			break;
 		case MotionNotify:
 			if ((ev.xmotion.time - lasttime) <= (1000 / 60))
-				continue;
-			lasttime = ev.xmotion.time;
-
-			nx = ocx + (ev.xmotion.x - x);
-			ny = ocy + (ev.xmotion.y - y);
-			if (abs(selmon->wx - nx) < snap)
-				nx = selmon->wx;
-			else if (abs((selmon->wx + selmon->ww) - (nx + WIDTH(c))) < snap)
-				nx = selmon->wx + selmon->ww - WIDTH(c);
-			if (abs(selmon->wy - ny) < snap)
-				ny = selmon->wy;
-			else if (abs((selmon->wy + selmon->wh) - (ny + HEIGHT(c))) < snap)
-				ny = selmon->wy + selmon->wh - HEIGHT(c);
-			if (!c->isfloating && selmon->lt[selmon->sellt]->arrange
-			&& (abs(nx - c->x) > snap || abs(ny - c->y) > snap))
-				togglefloating(NULL);
-			if (!selmon->lt[selmon->sellt]->arrange || c->isfloating)
-				resize(c, nx, ny, c->w, c->h, c->bw, 1);
-			break;
-		}
-	} while (ev.type != ButtonRelease);
-	XUngrabPointer(dpy, CurrentTime);
-	if ((m = recttomon(c->x, c->y, c->w, c->h)) != selmon) {
-		sendmon(c, m);
-		selmon = m;
-		focus(NULL);
-	}
-}
-
-void
-moveresize(const Arg *arg) {
-	/* only floating windows can be moved */
-	Client *c;
-	c = selmon->sel;
-	int x, y, w, h, nx, ny, nw, nh, ox, oy, ow, oh;
-	char xAbs, yAbs, wAbs, hAbs;
-	int msx, msy, dx, dy, nmx, nmy;
-	unsigned int dui;
-	Window dummy;
-
-	if (!c || !arg)
-		return;
-	if (selmon->lt[selmon->sellt]->arrange && !c->isfloating)
-		return;
-	if (sscanf((char *)arg->v, "%d%c %d%c %d%c %d%c", &x, &xAbs, &y, &yAbs, &w, &wAbs, &h, &hAbs) != 8)
-		return;
-
-	/* compute new window position; prevent window from be positioned outside the current monitor */
-	nw = c->w + w;
-	if (wAbs == 'W')
-		nw = w < selmon->mw - 2 * c->bw ? w : selmon->mw - 2 * c->bw;
-
-	nh = c->h + h;
-	if (hAbs == 'H')
-		nh = h < selmon->mh - 2 * c->bw ? h : selmon->mh - 2 * c->bw;
-
-	nx = c->x + x;
-	if (xAbs == 'X') {
-		if (x < selmon->mx)
-			nx = selmon->mx;
-		else if (x > selmon->mx + selmon->mw)
-			nx = selmon->mx + selmon->mw - nw - 2 * c->bw;
-		else
-			nx = x;
-	}
-
-	ny = c->y + y;
-	if (yAbs == 'Y') {
-		if (y < selmon->my)
-			ny = selmon->my;
-		else if (y > selmon->my + selmon->mh)
-			ny = selmon->my + selmon->mh - nh - 2 * c->bw;
-		else
-			ny = y;
-	}
-
-	ox = c->x;
-	oy = c->y;
-	ow = c->w;
-	oh = c->h;
-
-	XRaiseWindow(dpy, c->win);
-	Bool xqp = XQueryPointer(dpy, root, &dummy, &dummy, &msx, &msy, &dx, &dy, &dui);
-	resize(c, nx, ny, nw, nh, c->bw, True);
-
-	/* move cursor along with the window to avoid problems caused by the sloppy focus */
-	if (xqp && ox <= msx && (ox + ow) >= msx && oy <= msy && (oy + oh) >= msy)
-	{
-		nmx = c->x - ox + c->w - ow;
-		nmy = c->y - oy + c->h - oh;
-		XWarpPointer(dpy, None, None, 0, 0, 0, 0, nmx, nmy);
-	}
-}
-
-void
-moveresizeedge(const Arg *arg) {
-	/* move or resize floating window to edge of screen */
-	Client *c;
-	c = selmon->sel;
-	char e;
-	int nx, ny, nw, nh, ox, oy, ow, oh, bp;
-	int msx, msy, dx, dy, nmx, nmy;
-	int starty;
-	unsigned int dui;
-	Window dummy;
-
-	nx = c->x;
-	ny = c->y;
-	nw = c->w;
-	nh = c->h;
-
-	if(abs(selmon->showbar) + abs(selmon->showebar) == 2) {
-		starty = topbar ? 2 * bh : 0;
-		bp = !topbar ? 2 * bh : 0;
-	} else if(abs(selmon->showbar) + abs(selmon->showebar) == 1) {
-		starty = topbar ? bh : 0;
-		bp = !topbar ? bh : 0;
-	} else {
-		starty = 0;
-		bp = 0;
-	}
-
-	if (!c || !arg)
-		return;
-	if (selmon->lt[selmon->sellt]->arrange && !c->isfloating)
-		return;
-	if(sscanf((char *)arg->v, "%c", &e) != 1)
-		return;
-
-	if(e == 't')
-		ny = starty;
-
-	if(e == 'b')
-		ny = c->h > selmon->mh - 2 * c->bw ? c->h - bp : selmon->mh - c->h - 2 * c->bw - bp;
-
-	if(e == 'l')
-		nx = selmon->mx;
-
-	if(e == 'r')
-		nx = c->w > selmon->mw - 2 * c->bw ? selmon->mx + c->w : selmon->mx + selmon->mw - c->w - 2 * c->bw;
-
-	if(e == 'T') {
-		/* if you click to resize again, it will return to old size/position */
-		if(c->h + starty == c->oldh + c->oldy) {
-			nh = c->oldh;
-			ny = c->oldy;
-		} else {
-			nh = c->h + c->y - starty;
-			ny = starty;
-		}
-	}
-
-	if(e == 'B')
-		nh = c->h + c->y + 2 * c->bw + bp == selmon->mh ? c->oldh : selmon->mh - c->y - 2 * c->bw - bp;
+				continue;
+			lasttime = ev.xmotion.time;
 
-	if(e == 'L') {
-		if(selmon->mx + c->w == c->oldw + c->oldx) {
-			nw = c->oldw;
-			nx = c->oldx;
-		} else {
-			nw = c->w + c->x - selmon->mx;
-			nx = selmon->mx;
+			nx = ocx + (ev.xmotion.x - x);
+			ny = ocy + (ev.xmotion.y - y);
+			if (abs(selmon->wx - nx) < snap)
+				nx = selmon->wx;
+			else if (abs((selmon->wx + selmon->ww) - (nx + WIDTH(c))) < snap)
+				nx = selmon->wx + selmon->ww - WIDTH(c);
+			if (abs(selmon->wy - ny) < snap)
+				ny = selmon->wy;
+			else if (abs((selmon->wy + selmon->wh) - (ny + HEIGHT(c))) < snap)
+				ny = selmon->wy + selmon->wh - HEIGHT(c);
+			if (!c->isfloating && selmon->lt[selmon->sellt]->arrange
+			&& (abs(nx - c->x) > snap || abs(ny - c->y) > snap))
+				togglefloating(NULL);
+			if (!selmon->lt[selmon->sellt]->arrange || c->isfloating)
+				resize(c, nx, ny, c->w, c->h, c->bw, 1);
+			break;
 		}
-	}
-
-	if(e == 'R')
-		nw = c->w + c->x + 2 * c->bw == selmon->mx + selmon->mw ? c->oldw : selmon->mx + selmon->mw - c->x - 2 * c->bw;
-
-	ox = c->x;
-	oy = c->y;
-	ow = c->w;
-	oh = c->h;
-
-	XRaiseWindow(dpy, c->win);
-	Bool xqp = XQueryPointer(dpy, root, &dummy, &dummy, &msx, &msy, &dx, &dy, &dui);
-	resize(c, nx, ny, nw, nh, c->bw, True);
-
-	/* move cursor along with the window to avoid problems caused by the sloppy focus */
-	if (xqp && ox <= msx && (ox + ow) >= msx && oy <= msy && (oy + oh) >= msy) {
-		nmx = c->x - ox + c->w - ow;
-		nmy = c->y - oy + c->h - oh;
-		XWarpPointer(dpy, None, None, 0, 0, 0, 0, nmx, nmy);
+	} while (ev.type != ButtonRelease);
+	XUngrabPointer(dpy, CurrentTime);
+	if ((m = recttomon(c->x, c->y, c->w, c->h)) != selmon) {
+		sendmon(c, m);
+		selmon = m;
+		focus(NULL);
 	}
 }
 
@@ -2208,13 +1867,15 @@ propertynotify(XEvent *e)
 		}
 		else
 			updatesystrayiconstate(c, ev);
-		updatesystray();
+		if (esys)
+			drawebar(rawstext, selmon, 0);
+		else
+			drawbar(selmon, 0);
 	}
 
-	if ((ev->window == root) && (ev->atom == XA_WM_NAME)) {
-		if (!fake_signal())
-			updatestatus();
-	} else if (ev->state == PropertyDelete)
+	if ((ev->window == root) && (ev->atom == XA_WM_NAME))
+		updatestatus();
+	else if (ev->state == PropertyDelete)
 		return; /* ignore */
 	else if ((c = wintoclient(ev->window))) {
 		switch(ev->atom) {
@@ -2236,8 +1897,7 @@ propertynotify(XEvent *e)
 			updatetitle(c);
 			if (c == c->mon->sel)
 				drawbar(c->mon, 0);
-		}
-		else if (ev->atom == netatom[NetWMIcon]) {
+		} else if (ev->atom == netatom[NetWMIcon]) {
 			updateicon(c);
 			if (c == c->mon->sel)
 				drawbar(c->mon, 0);
@@ -2247,25 +1907,6 @@ propertynotify(XEvent *e)
 	}
 }
 
-Client *
-nextc(Client *c, float f) {
-	if(!f)
-		return nexttiled(c);
-
-	for(; c && !ISVISIBLE(c); c = c->next);
-	return c;
-}
-
-static Client *
-prevc(Client *c, float f) {
-	Client *p, *r;
-
-	for(p = selmon->clients, r = NULL; c && p && p != c; p = p->next)
-		if((f || !p->isfloating) && ISVISIBLE(p))
-			r = p;
-	return r;
-}
-
 void
 quit(const Arg *arg)
 {
@@ -2317,17 +1958,19 @@ resizemouse(const Arg *arg)
 {
 	int ocx, ocy, nw, nh;
 	int ocx2, ocy2, nx, ny;
-	Client *c;
-	Monitor *m;
-	XEvent ev;
 	int horizcorner, vertcorner;
 	int di;
 	unsigned int dui;
 	Window dummy;
+	Client *c;
+	Monitor *m;
+	XEvent ev;
 	Time lasttime = 0;
 
 	if (!(c = selmon->sel))
 		return;
+	if (c->isfullscreen) /* no support resizing fullscreen windows by mouse */
+		return;
 	restack(selmon);
 	ocx = c->x;
 	ocy = c->y;
@@ -2343,7 +1986,6 @@ resizemouse(const Arg *arg)
 	XWarpPointer (dpy, None, c->win, 0, 0, 0, 0,
 		      horizcorner ? (-c->bw) : (c->w + c->bw - 1),
 		      vertcorner ? (-c->bw) : (c->h + c->bw - 1));
-
 	do {
 		XMaskEvent(dpy, MOUSEMASK|ExposureMask|SubstructureRedirectMask, &ev);
 		switch(ev.type) {
@@ -2412,7 +2054,7 @@ restack(Monitor *m)
 	}
 	for (c = m->stack; c; c = c->snext)
 		shadowfloat(c);
-    XSync(dpy, False);
+	XSync(dpy, False);
 	while (XCheckMaskEvent(dpy, EnterWindowMask, &ev));
 }
 
@@ -2464,7 +2106,7 @@ sendmon(Client *c, Monitor *m)
 	detachstack(c);
 	c->mon = m;
 	c->tags = m->tagset[m->seltags]; /* assign tags of target monitor */
-	switch(attachdirection){
+	switch(attachdirection) {
 		case 1:
 			attachabove(c);
 			break;
@@ -2486,6 +2128,8 @@ sendmon(Client *c, Monitor *m)
 	attachstack(c);
 	focus(NULL);
 	arrange(NULL);
+	if (c->switchtag)
+		c->switchtag = 0;
 }
 
 void
@@ -2544,42 +2188,33 @@ setfocus(Client *c)
 }
 
 void
-setactfullscreen(Client *c)
+setfullscreen(Client *c, int fullscreen)
 {
-	if (!c->isactfullscreen) {
-		c->isactfullscreen = 1;
+	if (fullscreen && !c->isfullscreen) {
+		XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
+			PropModeReplace, (unsigned char*)&netatom[NetWMFullscreen], 1);
+		c->isfullscreen = 1;
 		c->oldstate = c->isfloating;
+		c->oldbw = c->bw;
+		c->bw = 0;
 		c->isfloating = 1;
 		resizeclient(c, c->mon->mx, c->mon->my, c->mon->mw, c->mon->mh, 0);
 		XRaiseWindow(dpy, c->win);
-	} else if (c->isactfullscreen){
-		c->isactfullscreen = 0;
+	} else if (!fullscreen && c->isfullscreen){
+		XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
+			PropModeReplace, (unsigned char*)0, 0);
+		c->isfullscreen = 0;
 		c->isfloating = c->oldstate;
+		c->bw = c->oldbw;
 		c->x = c->oldx;
 		c->y = c->oldy;
 		c->w = c->oldw;
 		c->h = c->oldh;
-		c->bw = c->oldbw;
 		resizeclient(c, c->x, c->y, c->w, c->h, c->bw);
 		arrange(c->mon);
 	}
 }
 
-void
-setfullscreen(Client *c, int fullscreen)
-{
-	if (fullscreen && !c->isfullscreen) {
-		XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
-			PropModeReplace, (unsigned char*)&netatom[NetWMFullscreen], 1);
-		c->isfullscreen = 1;
-	} else if (!fullscreen && c->isfullscreen){
-		XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
-			PropModeReplace, (unsigned char*)0, 0);
-		c->isfullscreen = 0;
-	}
-    demoncleaner(0);
-}
-
 void
 setlayout(const Arg *arg)
 {
@@ -2642,7 +2277,7 @@ setup(void)
 	wmatom[WMTakeFocus] = XInternAtom(dpy, "WM_TAKE_FOCUS", False);
 	netatom[NetActiveWindow] = XInternAtom(dpy, "_NET_ACTIVE_WINDOW", False);
 	netatom[NetSupported] = XInternAtom(dpy, "_NET_SUPPORTED", False);
-    netatom[NetSystemTray] = XInternAtom(dpy, "_NET_SYSTEM_TRAY_S0", False);
+	netatom[NetSystemTray] = XInternAtom(dpy, "_NET_SYSTEM_TRAY_S0", False);
 	netatom[NetSystemTrayOP] = XInternAtom(dpy, "_NET_SYSTEM_TRAY_OPCODE", False);
 	netatom[NetSystemTrayOrientation] = XInternAtom(dpy, "_NET_SYSTEM_TRAY_ORIENTATION", False);
 	netatom[NetSystemTrayOrientationHorz] = XInternAtom(dpy, "_NET_SYSTEM_TRAY_ORIENTATION_HORZ", False);
@@ -2660,7 +2295,7 @@ setup(void)
 	xatom[Xembed] = XInternAtom(dpy, "_XEMBED", False);
 	xatom[XembedInfo] = XInternAtom(dpy, "_XEMBED_INFO", False);
     wunshadow = XInternAtom(dpy, "_COMPTON_SHADOW", False);
-    /* init cursors */
+	/* init cursors */
 	cursor[CurNormal] = drw_cur_create(drw, XC_left_ptr);
 	cursor[CurResize] = drw_cur_create(drw, XC_sizing);
 	cursor[CurMove] = drw_cur_create(drw, XC_fleur);
@@ -2728,9 +2363,8 @@ showhide(Client *c)
 	if (ISVISIBLE(c)) {
 		/* show clients top down */
 		XMoveWindow(dpy, c->win, c->x, c->y);
-		if (!c->mon->lt[c->mon->sellt]->arrange || c->isfloating)
+		if ((!c->mon->lt[c->mon->sellt]->arrange || c->isfloating) && !c->isfullscreen)
 			resize(c, c->x, c->y, c->w, c->h, c->bw, 0);
-//			resize(c, c->x, c->y, c->w, c->h, borderpx, 0);
 		showhide(c->snext);
 	} else {
 		/* hide clients bottom up */
@@ -2780,6 +2414,8 @@ tag(const Arg *arg)
 {
 	if (selmon->sel && arg->ui & TAGMASK) {
 		selmon->sel->tags = arg->ui & TAGMASK;
+		if (selmon->sel->switchtag)
+			selmon->sel->switchtag = 0;
 		focus(NULL);
 		arrange(selmon);
 	}
@@ -2967,7 +2603,7 @@ togglebar(const Arg *arg)
 	}
 	XMoveWindow(dpy, selmon->barwin, selmon->wx + (bargap ? selmon->gappx : 0), selmon->by);
 	XMoveWindow(dpy, selmon->ebarwin, selmon->wx + (bargap ? selmon->gappx : 0), selmon->eby);
-	XMoveWindow(dpy, selmon->tagwin, rtag ? selmon->ww - selmon->ww / scalepreview - (bargap ? selmon->gappx : 0) : selmon->wx + (bargap ? selmon->gappx : 0), selmon->wy);
+	XMoveResizeWindow(dpy, selmon->tagwin, rtag ? selmon->ww - selmon->ww / scalepreview - (bargap ? selmon->gappx : 0) : selmon->wx + (bargap ? selmon->gappx : 0), selmon->wy, sw / scalepreview, sh / scalepreview);
 	arrange(selmon);
 }
 
@@ -2989,7 +2625,7 @@ toggleebar(const Arg *arg)
 	}
 	XMoveWindow(dpy, selmon->barwin, selmon->wx + (bargap ? selmon->gappx : 0), selmon->by);
 	XMoveWindow(dpy, selmon->ebarwin, selmon->wx + (bargap ? selmon->gappx : 0), selmon->eby);
-	XMoveWindow(dpy, selmon->tagwin, rtag ? selmon->ww - selmon->ww / scalepreview - (bargap ? selmon->gappx : 0) : selmon->wx + (bargap ? selmon->gappx : 0), selmon->wy);
+	XMoveResizeWindow(dpy, selmon->tagwin, rtag ? selmon->ww - selmon->ww / scalepreview - (bargap ? selmon->gappx : 0) : selmon->wx + (bargap ? selmon->gappx : 0), selmon->wy, sw / scalepreview, sh / scalepreview);
     arrange(selmon);
 }
 
@@ -3011,7 +2647,10 @@ togglefloating(const Arg *arg)
 {
 	if (!selmon->sel)
 		return;
+	if (selmon->sel->isfullscreen) /* no support for fullscreen windows */
+		return;
 	selmon->sel->isfloating = !selmon->sel->isfloating || selmon->sel->isfixed;
+	XSetWindowBorder(dpy, selmon->sel->win, scheme[SchemeBorder][selmon->sel->isfloating ? ColFloat : ColBorder].pixel);
 	if (selmon->sel->isfloating)
 		/* restore last known float dimensions */
 		resize(selmon->sel, selmon->sel->sfx, selmon->sel->sfy,
@@ -3030,18 +2669,10 @@ togglefloating(const Arg *arg)
 	arrangemon(selmon);
 }
 
-void
-togglefullscr(const Arg *arg)
-{
-  if(selmon->sel)
-    setactfullscreen(selmon->sel);
-}
-
 void
 toggletag(const Arg *arg)
 {
-	unsigned int newtags;
-	unsigned int i;
+	unsigned int i, newtags;
 
 	if (!selmon->sel)
 		return;
@@ -3088,38 +2719,32 @@ toggleview(const Arg *arg)
 	size_t j;
 	for (c = nexttiled(selmon->clients), j = 0; c && j < selmon->nmaster; c = nexttiled(c->next), ++j)
 		masters[selmon->nmaster - (j + 1)] = c;
-	for (size_t j = 0; j < selmon->nmaster; ++j)
+	for (j = 0; j < selmon->nmaster; ++j)
 		if (masters[j])
 			pop(masters[j]);
 	free(masters);
 	focus(selected);
+
 	if (newtagset) {
 		selmon->tagset[selmon->seltags] = newtagset;
-
 		if (newtagset == ~0) {
 			selmon->pertag->prevtag = selmon->pertag->curtag;
 			selmon->pertag->curtag = 0;
 		}
-
 		/* test if the user did not select the same tag */
 		if (!(newtagset & 1 << (selmon->pertag->curtag - 1))) {
 			selmon->pertag->prevtag = selmon->pertag->curtag;
 			for (i = 0; !(newtagset & 1 << i); i++) ;
 			selmon->pertag->curtag = i + 1;
 		}
-
 		/* apply settings for this view */
 		selmon->nmaster = selmon->pertag->nmasters[selmon->pertag->curtag];
 		selmon->mfact = selmon->pertag->mfacts[selmon->pertag->curtag];
 		selmon->sellt = selmon->pertag->sellts[selmon->pertag->curtag];
 		selmon->lt[selmon->sellt] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt];
 		selmon->lt[selmon->sellt^1] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt^1];
-
 		if (selmon->showbar != selmon->pertag->showbars[selmon->pertag->curtag])
 			togglebar(NULL);
-		if (selmon->showebar != selmon->pertag->showebars[selmon->pertag->curtag])
-			toggleebar(NULL);
-
 		focus(NULL);
 		arrange(selmon);
 	}
@@ -3131,14 +2756,7 @@ unfocus(Client *c, int setfocus)
 	if (!c)
 		return;
 	grabbuttons(c, 0);
-	if(c->isfloating)
-		XSetWindowBorder(dpy, c->win, scheme[SchemeBorder][ColFloat].pixel);
-	else {
-		if ( selmon->gappx > borderpx)
-			XSetWindowBorder(dpy, c->win, scheme[SchemeBorder][ColBg].pixel);
-		else
-			XSetWindowBorder(dpy, c->win, scheme[SchemeBorder][ColBorder].pixel);
-	}
+	XSetWindowBorder(dpy, c->win, scheme[SchemeBorder][c->isfloating ? ColFloat : (selmon->gappx > borderpx) ? ColBg : ColBorder].pixel);
 	if (setfocus) {
 		XSetInputFocus(dpy, root, RevertToPointerRoot, CurrentTime);
 		XDeleteProperty(dpy, root, netatom[NetActiveWindow]);
@@ -3150,11 +2768,11 @@ unmanage(Client *c, int destroyed)
 {
 	Client *s;
 	Monitor *m = c->mon;
+	unsigned int switchtag = c->switchtag;
 	XWindowChanges wc;
 
 	if (c->swallowing)
 		unswallow(c);
-
 	s = swallowingclient(c->win);
 	if (s)
 		s->swallowing = NULL;
@@ -3177,10 +2795,8 @@ unmanage(Client *c, int destroyed)
 	focus(NULL);
 	updateclientlist();
 	arrange(m);
-	if (c->switchtotag) {
-		Arg a = { .ui = c->switchtotag };
-		view(&a);
-	}
+	if (switchtag)
+		view(&((Arg) { .ui = switchtag }));
 }
 
 void
@@ -3198,8 +2814,10 @@ unmapnotify(XEvent *e)
 		/* KLUDGE! sometimes icons occasionally unmap their windows, but do
 		 * _not_ destroy them. We map those windows back */
 		XMapRaised(dpy, c->win);
-		removesystrayicon(c);
-		updatesystray();
+		if (esys)
+			drawebar(rawstext, selmon, 0);
+		else
+			drawbar(selmon, 0);
 	}
 }
 
@@ -3226,8 +2844,8 @@ updatebars(void)
 			if (esys == 0 && showsystray && m == systraytomon(m))
 				w -= getsystraywidth();
 			m->barwin = XCreateWindow(dpy, root, m->wx + bgap, m->by, w - 2 * bgap, bh, 0, depth,
-			                          InputOutput, visual,
-			                          CWOverrideRedirect|CWBackPixel|CWBorderPixel|CWColormap|CWEventMask, &wa);
+									InputOutput, visual,
+									CWOverrideRedirect|CWBackPixel|CWBorderPixel|CWColormap|CWEventMask, &wa);
 			XDefineCursor(dpy, m->barwin, cursor[CurNormal]->cursor);
 			if (esys == 0 && showsystray && m == systraytomon(m))
 				XMapRaised(dpy, systray->win);
@@ -3235,7 +2853,7 @@ updatebars(void)
 			XSetClassHint(dpy, m->barwin, &ch);
 			XSetWMName(dpy, m->barwin, &tp);
 		}
-        if(!m->ebarwin) {
+        if (!m->ebarwin) {
 			w = m->ww;
 			if (esys == 1 && showsystray && m == systraytomon(m))
 				w -= getsystraywidth();
@@ -3343,7 +2961,7 @@ updategeom(void)
 					m->clients = c->next;
 					detachstack(c);
 					c->mon = mons;
-					switch(attachdirection){
+					switch(attachdirection) {
 					case 1:
 						attachabove(c);
 						break;
@@ -3528,11 +3146,10 @@ view(const Arg *arg)
 	if (arg->ui & TAGMASK) {
 		selmon->tagset[selmon->seltags] = arg->ui & TAGMASK;
 		selmon->pertag->prevtag = selmon->pertag->curtag;
-
 		if (arg->ui == ~0)
 			selmon->pertag->curtag = 0;
 		else {
-			for (i = 0; !(arg->ui & 1 << i); i++) ;
+			for (i = 0; !(arg->ui & 1 << i); i++);
 			selmon->pertag->curtag = i + 1;
 		}
 	} else {
@@ -3626,30 +3243,31 @@ void
 zoom(const Arg *arg)
 {
 	Client *c = selmon->sel;
-	Client *at = NULL, *cold, *cprevious = NULL;
+	Client *at = NULL, *cold, *cprevious = NULL, *p;
 
 	if (!selmon->lt[selmon->sellt]->arrange
-	|| (selmon->sel && selmon->sel->isfloating))
+	|| (selmon->sel && selmon->sel->isfloating) || !c)
 		return;
-	if (c == nexttiled(selmon->clients)) {
-		at = findbefore(prevzoom);
+	if (c == nexttiled(c->mon->clients)) {
+		p = c->mon->pertag->prevzooms[c->mon->pertag->curtag];
+		at = findbefore(p);
 		if (at)
 			cprevious = nexttiled(at->next);
-		if (!cprevious || cprevious != prevzoom) {
-			prevzoom = NULL;
+		if (!cprevious || cprevious != p) {
+			c->mon->pertag->prevzooms[c->mon->pertag->curtag] = NULL;
 			if (!c || !(c = nexttiled(c->next)))
 				return;
 		} else
 			c = cprevious;
 	}
-	cold = nexttiled(selmon->clients);
+	cold = nexttiled(c->mon->clients);
 	if (c != cold && !at)
 		at = findbefore(c);
 	detach(c);
 	attach(c);
 	/* swap windows instead of pushing the previous one down */
 	if (c != cold && at) {
-		prevzoom = cold;
+		c->mon->pertag->prevzooms[c->mon->pertag->curtag] = cold;
 		if (cold && at != cold) {
 			detach(cold);
 			cold->next = at->next;
@@ -3730,13 +3348,12 @@ attachtop(Client *c)
 }
 
 Client *
-findbefore(Client *c)
-{
-	Client *tmp;
-	if (c == selmon->clients)
+findbefore(Client *c) {
+	Client *p;
+	if (!c || c == c->mon->clients)
 		return NULL;
-	for (tmp = selmon->clients; tmp && tmp->next != c; tmp = tmp->next);
-	return tmp;
+	for (p = c->mon->clients; p && p->next != c; p = p->next);
+	return p;
 }
 
 void
@@ -3955,10 +3572,10 @@ dragfact(const Arg *arg)
 
 void
 drawtheme(int x, int s, int status, int theme) {
-// STATUS 		 THEME
-// unfocus 	= 1  default 	= 0
-// focus 	= 2  button 	= 1
-// select 	= 3  floater 	= 2
+	/* STATUS 		 THEME
+	 * unfocus 	= 1  default 	= 0
+	 * focus 	= 2  button 	= 1
+	 * select 	= 3  floater 	= 2	*/
 
 	if (x + s == 0) {
 		drw_setscheme(drw, scheme[LENGTH(colors)]);
@@ -4039,7 +3656,8 @@ drawtheme(int x, int s, int status, int theme) {
 }
 
 void
-drawbartabgroups(Monitor *m, int x, int r, int xpos, int passx) {
+drawtabgroups(Monitor *m, int x, int r, int xpos, int passx)
+{
 	Client *c;
 	TabGroup *tg_head = NULL, *tg, *tg2;
 	int tabwidth, tabx, tabgroupwidth, bw;
@@ -4099,8 +3717,8 @@ drawbartabgroups(Monitor *m, int x, int r, int xpos, int passx) {
 		tabwidth = (tabgroupwidth / tg->n);
 		tabx = MAX(x, tg->start) + (tabwidth * tg->i);
 		tabwidth += (tg->n == tg->i + 1 ?  tabgroupwidth % tg->n : 0);
-		drawbartab(m, c, tabx, tabwidth, xpos, tg->active);
-		drawbartaboptionals(m, c, tabx, tabwidth, tg->active);
+		drawtab(m, c, tabx, tabwidth, xpos, tg->active);
+		drawtaboptionals(m, c, tabx, tabwidth, tg->active);
 		if (m ->lt[m->sellt]->arrange == tile && abs(m->ltaxis[0]) != 2) {
 			if (passx > 0 && passx > tabx && passx < tabx + tabwidth) {
 				focus(c);
@@ -4120,7 +3738,8 @@ drawbartabgroups(Monitor *m, int x, int r, int xpos, int passx) {
 	while (tg_head != NULL) { tg = tg_head; tg_head = tg_head->next; free(tg); }
 }
 
-void drawbartab(Monitor *m, Client *c, int x, int w, int xpos, int tabgroup_active) {
+void drawtab(Monitor *m, Client *c, int x, int w, int xpos, int tabgroup_active)
+{
 	if (!c) return;
 	int n = 0;
 	uint32_t tmp[(bh - 2 * iconpad) * (bh - 2 * iconpad)];
@@ -4136,21 +3755,21 @@ void drawbartab(Monitor *m, Client *c, int x, int w, int xpos, int tabgroup_acti
 	}
 	if (n != 1) {
 		if (xpos && xpos >= x && xpos <= x + w) {
-			esep = x;
-			eblock = w;
+			fsep = x;
+			fblock = w;
 		}
 		if (m->sel == c)
 			drawtheme(0,0,3,tabbartheme);
-		else if (x == esep && w == eblock && w)
+		else if (x == fsep && w == fblock && w)
 			drawtheme(0,0,2,tabbartheme);
 		else
 			drawtheme(0,0,1,tabbartheme);
-		drw_text(drw, x, (bartheme && m->sel != c) ? x != esep || w != eblock ? -1 : 0 : 0, w, bh, lrpad / 2 + (c->icon ? c->icon->width + iconspacing : 0), c->name, 0);
-		if (c->icon) drw_img(drw, x + lrpad / 2, (bh - c->icon->height) / 2 - ((bartheme && m->sel != c) ? x != esep || w != eblock ? 1 : 0 : 0), c->icon, tmp);
+		drw_text(drw, x, (bartheme && m->sel != c) ? x != fsep || w != fblock ? -1 : 0 : 0, w, bh, lrpad / 2 + (c->icon ? c->icon->width + iconspacing : 0), c->name, 0);
+		if (c->icon) drw_img(drw, x + lrpad / 2, (bh - c->icon->height) / 2 - ((bartheme && m->sel != c) ? x != fsep || w != fblock ? 1 : 0 : 0), c->icon, tmp);
 		if (bartheme) {
 			if(m->sel == c)
 				drawtheme(x, w, 3, tabbartheme);
-			else if (x != esep || w != eblock)
+			else if (x != fsep || w != fblock)
 				drawtheme(x, w, 1, tabbartheme);
 			else
 				drawtheme(x, w, 2, tabbartheme);
@@ -4161,7 +3780,8 @@ void drawbartab(Monitor *m, Client *c, int x, int w, int xpos, int tabgroup_acti
 	}
 }
 
-void drawbartaboptionals(Monitor *m, Client *c, int x, int w, int tabgroup_active) {
+void drawtaboptionals(Monitor *m, Client *c, int x, int w, int tabgroup_active)
+{
 	int i, draw_grid, nclienttags, nviewtags;
 
 	if (!c) return;
@@ -4182,14 +3802,14 @@ void drawbartaboptionals(Monitor *m, Client *c, int x, int w, int tabgroup_activ
 			drw_rect(drw, (
 					x + w
 					- BARTABGROUPS_INDICATORSPADPX
-					- ((LENGTH(tags) / BARTABGROUPS_TAGSROWS) * BARTABGROUPS_TAGSPX)
-					- (i % (LENGTH(tags)/BARTABGROUPS_TAGSROWS))
-					+ ((i % (LENGTH(tags) / BARTABGROUPS_TAGSROWS)) * BARTABGROUPS_TAGSPX)
+					- ((LENGTH(tags) / tagrows) * BARTABGROUPS_TAGSPX)
+					- (i % (LENGTH(tags)/tagrows))
+					+ ((i % (LENGTH(tags) / tagrows)) * BARTABGROUPS_TAGSPX)
 				),
 				(
 					BARTABGROUPS_INDICATORSPADPX
-					+ ((i / (LENGTH(tags)/BARTABGROUPS_TAGSROWS)) * BARTABGROUPS_TAGSPX)
-					- ((i / (LENGTH(tags)/BARTABGROUPS_TAGSROWS)))
+					+ ((i / (LENGTH(tags)/tagrows)) * BARTABGROUPS_TAGSPX)
+					- ((i / (LENGTH(tags)/tagrows)))
 				),
 				BARTABGROUPS_TAGSPX, BARTABGROUPS_TAGSPX, (c->tags >> i) & 1, 0
 			);
@@ -4197,46 +3817,44 @@ void drawbartaboptionals(Monitor *m, Client *c, int x, int w, int tabgroup_activ
 	}
 }
 
-void drawtaggrid(Monitor *m, int *x_pos, unsigned int occ)
-{
-    unsigned int x, y, h, max_x, columns;
-    int invert, i,j, k;
-
-    h = bh / tagrows;
-    x = max_x = *x_pos;
-    y = 0;
-    columns = LENGTH(tags) / tagrows + ((LENGTH(tags) % tagrows > 0) ? 1 : 0);
-
-    /* Firstly we will fill the borders of squares */
-
+void
+drawtaggrid(Monitor *m, int *x_pos, unsigned int occ)
+{
+	unsigned int x, y, h, max_x, columns;
+	int invert, i,j, k;
+	
+	h = bh / tagrows;
+	x = max_x = *x_pos;
+	y = 0;
+	columns = LENGTH(tags) / tagrows + ((LENGTH(tags) % tagrows > 0) ? 1 : 0);
+	
+	/* Firstly we will fill the borders of squares */
+	
 	XSetForeground(drw->dpy, drw->gc, scheme[SchemeTag][ColBorder].pixel);
-    XFillRectangle(dpy, drw->drawable, drw->gc, x, y, h*columns + 1, bh);
-
-    /* We will draw LENGTH(tags) squares in tagraws raws. */
+	XFillRectangle(dpy, drw->drawable, drw->gc, x, y, h*columns + 1, bh);
+	
+	/* We will draw LENGTH(tags) squares in tagraws raws. */
 	for(j = 0,  i= 0; j < tagrows; j++) {
-        x = *x_pos;
-        for (k = 0; k < columns && i < LENGTH(tags); k++, i++) {
-		    invert = m->tagset[m->seltags] & 1 << i ? 0 : 1;
-
-            /* Select active color for current square */
-            XSetForeground(drw->dpy, drw->gc, !invert ? scheme[SchemeTag][ColFg].pixel :
-                                scheme[SchemeTag][ColBg].pixel);
-            XFillRectangle(dpy, drw->drawable, drw->gc, x+1, y+1, h-1, h-1);
-
-            /* Mark square if tag has client */
-            if (occ & 1 << i) {
-                XSetForeground(drw->dpy, drw->gc, scheme[SchemeTag][ColFloat].pixel);
-                XFillRectangle(dpy, drw->drawable, drw->gc, x + 1, y + 1,
-                               h / 2, h / 2);
-            }
-		    x += h;
-            if (x > max_x) {
-                max_x = x;
-            }
-        }
-        y += h;
+		x = *x_pos;
+		for (k = 0; k < columns && i < LENGTH(tags); k++, i++) {
+			invert = m->tagset[m->seltags] & 1 << i ? 0 : 1;
+			
+			/* Select active color for current square */
+			XSetForeground(drw->dpy, drw->gc, !invert ? scheme[SchemeTag][ColFg].pixel : scheme[SchemeTag][ColBg].pixel);
+			XFillRectangle(dpy, drw->drawable, drw->gc, x+1, y+1, h-1, h-1);
+			
+			/* Mark square if tag has client */
+			if (occ & 1 << i) {
+				XSetForeground(drw->dpy, drw->gc, !invert ? scheme[SchemeTag][ColBg].pixel : scheme[SchemeTag][ColFloat].pixel);
+				XFillRectangle(dpy, drw->drawable, drw->gc, x + 1, y + 1, h / 2, h / 2);
+			}
+			x += h;
+			if (x > max_x)
+				max_x = x;
+		}
+		y += h;
 	}
-    *x_pos = max_x + 1;
+	*x_pos = max_x + 1;
 }
 
 void
@@ -4260,6 +3878,79 @@ getdwmblockspid()
 	return pid != 0 ? 0 : -1;
 }
 
+XImage *
+geticonprop(Window win)
+{
+	int format, iconsize;
+	unsigned long n, extra, *p = NULL;
+	Atom real;
+
+	iconsize = bh - 2 * iconpad;
+
+	if (XGetWindowProperty(dpy, win, netatom[NetWMIcon], 0L, LONG_MAX, False, AnyPropertyType,
+						   &real, &format, &n, &extra, (unsigned char **)&p) != Success)
+		return NULL;
+	if (n == 0 || format != 32) { XFree(p); return NULL; }
+
+	unsigned long *bstp = NULL;
+	uint32_t w, h, sz;
+
+	{
+		const unsigned long *end = p + n;
+		unsigned long *i;
+		uint32_t bstd = UINT32_MAX, d, m;
+		for (i = p; i < end - 1; i += sz) {
+			if ((w = *i++) > UINT16_MAX || (h = *i++) > UINT16_MAX) { XFree(p); return NULL; }
+			if ((sz = w * h) > end - i) break;
+			if ((m = w > h ? w : h) >= iconsize && (d = m - iconsize) < bstd) { bstd = d; bstp = i; }
+		}
+		if (!bstp) {
+			for (i = p; i < end - 1; i += sz) {
+				if ((w = *i++) > UINT16_MAX || (h = *i++) > UINT16_MAX) { XFree(p); return NULL; }
+				if ((sz = w * h) > end - i) break;
+				if ((d = iconsize - (w > h ? w : h)) < bstd) { bstd = d; bstp = i; }
+			}
+		}
+		if (!bstp) { XFree(p); return NULL; }
+	}
+
+	if ((w = *(bstp - 2)) == 0 || (h = *(bstp - 1)) == 0) { XFree(p); return NULL; }
+
+	uint32_t icw, ich, icsz;
+	if (w <= h) {
+		ich = iconsize; icw = w * iconsize / h;
+		if (icw == 0) icw = 1;
+	}
+	else {
+		icw = iconsize; ich = h * iconsize / w;
+		if (ich == 0) ich = 1;
+	}
+	icsz = icw * ich;
+
+	uint32_t i;
+#if ULONG_MAX > UINT32_MAX
+	uint32_t *bstp32 = (uint32_t *)bstp;
+	for (sz = w * h, i = 0; i < sz; ++i) bstp32[i] = bstp[i];
+#endif
+	uint32_t *icbuf = malloc(icsz << 2); if(!icbuf) { XFree(p); return NULL; }
+	if (w == icw && h == ich) memcpy(icbuf, bstp, icsz << 2);
+	else {
+		Imlib_Image origin = imlib_create_image_using_data(w, h, (DATA32 *)bstp);
+		if (!origin) { XFree(p); free(icbuf); return NULL; }
+		imlib_context_set_image(origin);
+		imlib_image_set_has_alpha(1);
+		Imlib_Image scaled = imlib_create_cropped_scaled_image(0, 0, w, h, icw, ich);
+		imlib_free_image_and_decache();
+		if (!scaled) { XFree(p); free(icbuf); return NULL; }
+		imlib_context_set_image(scaled);
+		imlib_image_set_has_alpha(1);
+		memcpy(icbuf, imlib_image_get_data_for_reading_only(), icsz << 2);
+		imlib_free_image_and_decache();
+	}
+	XFree(p);
+	return XCreateImage(drw->dpy, drw->visual, drw->depth, ZPixmap, 0, (char *)icbuf, icw, ich, 32, 0);
+}
+
 pid_t
 getparentprocess(pid_t p)
 {
@@ -4344,7 +4035,7 @@ inplacerotate(const Arg *arg)
 	unsigned int selidx = 0, i = 0;
 	Client *c = NULL, *stail = NULL, *mhead = NULL, *mtail = NULL, *shead = NULL;
 
-	// Shift client
+	// Determine positionings for insertclient
 	for (c = selmon->clients; c; c = c->next) {
 		if (ISVISIBLE(c) && !(c->isfloating)) {
 		if (selmon->sel == c) { selidx = i; }
@@ -4355,10 +4046,15 @@ inplacerotate(const Arg *arg)
 		i++;
 		}
 	}
-	if (arg->i < 0 && selidx >= selmon->nmaster) insertclient(stail, shead, 1);
-	if (arg->i > 0 && selidx >= selmon->nmaster) insertclient(shead, stail, 0);
-	if (arg->i < 0 && selidx < selmon->nmaster)  insertclient(mtail, mhead, 1);
-	if (arg->i > 0 && selidx < selmon->nmaster)  insertclient(mhead, mtail, 0);
+
+	// All clients rotate
+	if (arg->i == 2) insertclient(selmon->clients, stail, 0);
+	if (arg->i == -2) insertclient(stail, selmon->clients, 1);
+	// Stack xor master rotate
+	if (arg->i == -1 && selidx >= selmon->nmaster) insertclient(stail, shead, 1);
+	if (arg->i == 1 && selidx >= selmon->nmaster) insertclient(shead, stail, 0);
+	if (arg->i == -1 && selidx < selmon->nmaster)  insertclient(mtail, mhead, 1);
+	if (arg->i == 1 && selidx < selmon->nmaster)  insertclient(mhead, mtail, 0);
 
 	// Restore focus position
 	i = 0;
@@ -4405,51 +4101,50 @@ is_a_tmux_server(pid_t pid)
 void
 loadxrdb()
 {
-  Display *display;
-  char * resm;
-  XrmDatabase xrdb;
-  char *type;
-  XrmValue value;
-
-  display = XOpenDisplay(NULL);
-
-  if (display != NULL) {
-    resm = XResourceManagerString(display);
-
-    if (resm != NULL) {
-      xrdb = XrmGetStringDatabase(resm);
-
-      if (xrdb != NULL) {
-        XRDB_LOAD_COLOR("dwm.bar_fg",  bar_fg);
-        XRDB_LOAD_COLOR("dwm.bar_bg",  bar_bg);
-        XRDB_LOAD_COLOR("dwm.bar_brd", bar_brd);
-        XRDB_LOAD_COLOR("dwm.bar_flo", bar_flo);
-        XRDB_LOAD_COLOR("dwm.tag_fg",  tag_fg);
-        XRDB_LOAD_COLOR("dwm.tag_bg",  tag_bg);
-        XRDB_LOAD_COLOR("dwm.tag_brd", tag_brd);
-        XRDB_LOAD_COLOR("dwm.tag_flo", tag_flo);
-        XRDB_LOAD_COLOR("dwm.brd_fg",  brd_fg);
-        XRDB_LOAD_COLOR("dwm.brd_bg",  brd_bg);
-        XRDB_LOAD_COLOR("dwm.brd_brd", brd_brd);
-        XRDB_LOAD_COLOR("dwm.brd_flo", brd_flo);
-        XRDB_LOAD_COLOR("dwm.sel_fg",  sel_fg);
-        XRDB_LOAD_COLOR("dwm.sel_bg",  sel_bg);
-        XRDB_LOAD_COLOR("dwm.sel_brd", sel_brd);
-        XRDB_LOAD_COLOR("dwm.sel_flo", sel_flo);
-        XRDB_LOAD_COLOR("dwm.foc_fg",  foc_fg);
-        XRDB_LOAD_COLOR("dwm.foc_bg",  foc_bg);
-        XRDB_LOAD_COLOR("dwm.foc_brd", foc_brd);
-        XRDB_LOAD_COLOR("dwm.foc_flo", foc_flo);
-        XRDB_LOAD_COLOR("dwm.unf_fg",  unf_fg);
-        XRDB_LOAD_COLOR("dwm.unf_bg",  unf_bg);
-        XRDB_LOAD_COLOR("dwm.unf_brd", unf_brd);
-        XRDB_LOAD_COLOR("dwm.unf_flo", unf_flo);
-		XrmDestroyDatabase(xrdb);
-      }
-    }
-  }
-
-  XCloseDisplay(display);
+	Display *display;
+	char * resm;
+	XrmDatabase xrdb;
+	char *type;
+	XrmValue value;
+
+	display = XOpenDisplay(NULL);
+
+	if (display != NULL) {
+		resm = XResourceManagerString(display);
+
+		if (resm != NULL) {
+			xrdb = XrmGetStringDatabase(resm);
+
+			if (xrdb != NULL) {
+				XRDB_LOAD_COLOR("dwm.bar_fg",  bar_fg);
+				XRDB_LOAD_COLOR("dwm.bar_bg",  bar_bg);
+				XRDB_LOAD_COLOR("dwm.bar_brd", bar_brd);
+				XRDB_LOAD_COLOR("dwm.bar_flo", bar_flo);
+				XRDB_LOAD_COLOR("dwm.tag_fg",  tag_fg);
+				XRDB_LOAD_COLOR("dwm.tag_bg",  tag_bg);
+				XRDB_LOAD_COLOR("dwm.tag_brd", tag_brd);
+				XRDB_LOAD_COLOR("dwm.tag_flo", tag_flo);
+				XRDB_LOAD_COLOR("dwm.brd_fg",  brd_fg);
+				XRDB_LOAD_COLOR("dwm.brd_bg",  brd_bg);
+				XRDB_LOAD_COLOR("dwm.brd_brd", brd_brd);
+				XRDB_LOAD_COLOR("dwm.brd_flo", brd_flo);
+				XRDB_LOAD_COLOR("dwm.sel_fg",  sel_fg);
+				XRDB_LOAD_COLOR("dwm.sel_bg",  sel_bg);
+				XRDB_LOAD_COLOR("dwm.sel_brd", sel_brd);
+				XRDB_LOAD_COLOR("dwm.sel_flo", sel_flo);
+				XRDB_LOAD_COLOR("dwm.foc_fg",  foc_fg);
+				XRDB_LOAD_COLOR("dwm.foc_bg",  foc_bg);
+				XRDB_LOAD_COLOR("dwm.foc_brd", foc_brd);
+				XRDB_LOAD_COLOR("dwm.foc_flo", foc_flo);
+				XRDB_LOAD_COLOR("dwm.unf_fg",  unf_fg);
+				XRDB_LOAD_COLOR("dwm.unf_bg",  unf_bg);
+				XRDB_LOAD_COLOR("dwm.unf_brd", unf_brd);
+				XRDB_LOAD_COLOR("dwm.unf_flo", unf_flo);
+				XrmDestroyDatabase(xrdb);
+			}
+		}
+	}
+	XCloseDisplay(display);
 }
 
 void
@@ -4475,27 +4170,34 @@ void
 notifyhandler(const Arg *arg)
 {
 	if (arg->i == 1) {
-		istatustimer = eblock = esep = 0;
+		istatustimer = fblock = fsep = 0;
 		strncpy(rawstext, stext, sizeof(stext));
 		copyvalidchars(stext, rawstext);
 		drawebar(rawstext, selmon, 0);
 	}
 }
 
-static void
+Client *
+prevtiled(Client *c) {
+	Client *p, *r;
+
+	for(p = selmon->clients, r = NULL; p && p != c; p = p->next)
+		if(!p->isfloating && ISVISIBLE(p))
+			r = p;
+	return r;
+}
+
+void
 pushdown(const Arg *arg) {
-	Client *sel = selmon->sel;
-	Client *c;
+	Client *sel = selmon->sel, *c;
 
-	if(!sel || (sel->isfloating && !arg->f))
+	if(!sel || sel->isfloating)
 		return;
-	if((c = nextc(sel->next, arg->f))) {
-		/* attach after c */
+	if((c = nexttiled(sel->next))) {
 		detach(sel);
 		sel->next = c->next;
 		c->next = sel;
 	} else {
-		/* move to the front */
 		detach(sel);
 		attach(sel);
 	}
@@ -4503,15 +4205,13 @@ pushdown(const Arg *arg) {
 	arrange(selmon);
 }
 
-static void
+void
 pushup(const Arg *arg) {
-	Client *sel = selmon->sel;
-	Client *c;
+	Client *sel = selmon->sel, *c;
 
-	if(!sel || (sel->isfloating && !arg->f))
+	if(!sel || sel->isfloating)
 		return;
-	if((c = prevc(sel, arg->f))) {
-		/* attach before c */
+	if((c = prevtiled(sel))) {
 		detach(sel);
 		sel->next = c;
 		if(selmon->clients == c)
@@ -4521,7 +4221,6 @@ pushup(const Arg *arg) {
 			c->next = sel;
 		}
 	} else {
-		/* move to the end */
 		for(c = sel; c->next; c = c->next);
 		detach(sel);
 		sel->next = NULL;
@@ -4592,7 +4291,10 @@ resizerequest(XEvent *e)
 
 	if ((i = wintosystrayicon(ev->window))) {
 		updatesystrayicongeom(i, ev->width, ev->height);
-		updatesystray();
+		if (esys)
+			drawebar(rawstext, selmon, 0);
+		else
+			drawbar(selmon, 0);
 	}
 }
 
@@ -4762,15 +4464,13 @@ setgaps(const Arg *arg)
 	Client *c;
 	if ((arg->i == 0) || (selmon->gappx + arg->i < 0))
 		selmon->gappx = 0;
-	else {
-		if (selmon->gappx + arg->i < 50)
+	else if (selmon->gappx + arg->i < 50)
 		selmon->gappx += arg->i;
-		}
 	updatebarpos(selmon);
 	if (bargap) {
 		XMoveResizeWindow(dpy, selmon->barwin, selmon->wx + selmon->gappx, selmon->by, selmon->ww - 2 * selmon->gappx, bh);
 		XMoveResizeWindow(dpy, selmon->ebarwin, selmon->wx + selmon->gappx, selmon->eby, selmon->ww - 2 * selmon->gappx, bh);
-		XMoveWindow(dpy, selmon->tagwin, rtag ? selmon->ww - selmon->gappx - selmon->ww / scalepreview : selmon->wx + selmon->gappx, selmon->wy);
+		XMoveResizeWindow(dpy, selmon->tagwin, rtag ? selmon->ww - selmon->gappx - selmon->ww / scalepreview : selmon->wx + selmon->gappx, selmon->wy, sw / scalepreview, sh / scalepreview);
 	}
 	if ((selmon->gappx == 1 * borderpx && arg->i < 0)) {
 		for (c = nexttiled(selmon->clients); c; c = nexttiled(c->next))
@@ -4937,80 +4637,71 @@ switchcol(const Arg *arg)
 	}
 }
 
-void switchtag(const Arg *arg)
-{
-    unsigned int columns;
-    unsigned int new_tagset = 0;
-    unsigned int pos, i;
-    int col, row;
-    Arg new_arg;
-
-    columns = (drawtagmask & DRAWCLASSICTAGS) ? LENGTH(tags) : LENGTH(tags) / tagrows + ((LENGTH(tags) % tagrows > 0) ? 1 : 0);
-
-    for (i = 0; i < LENGTH(tags); ++i) {
-        if (!(selmon->tagset[selmon->seltags] & 1 << i)) {
-            continue;
-        }
-        pos = i;
-        row = pos / columns;
-        col = pos % columns;
-        if (arg->ui & SWITCHTAG_UP) {     /* UP */
-            row --;
-            if (row < 0) {
-                row = tagrows - 1;
-            }
-            do {
-                pos = row * columns + col;
-                row --;
-            } while (pos >= LENGTH(tags));
-        }
-        if (arg->ui & SWITCHTAG_DOWN) {     /* DOWN */
-            row ++;
-            if (row >= tagrows) {
-                row = 0;
-            }
-            pos = row * columns + col;
-            if (pos >= LENGTH(tags)) {
-                row = 0;
-            }
-            pos = row * columns + col;
-        }
-        if (arg->ui & SWITCHTAG_LEFT) {     /* LEFT */
-            col --;
-            if (col < 0) {
-                col = columns - 1;
-            }
-            do {
-                pos = row * columns + col;
-                col --;
-            } while (pos >= LENGTH(tags));
-        }
-        if (arg->ui & SWITCHTAG_RIGHT) {     /* RIGHT */
-            col ++;
-            if (col >= columns) {
-                col = 0;
-            }
-            pos = row * columns + col;
-            if (pos >= LENGTH(tags)) {
-                col = 0;
-                pos = row * columns + col;
-            }
-        }
-        new_tagset |= 1 << pos;
-    }
-    new_arg.ui = new_tagset;
-    if (arg->ui & SWITCHTAG_TOGGLETAG) {
-        toggletag(&new_arg);
-    }
-    if (arg->ui & SWITCHTAG_TAG) {
-        tag(&new_arg);
-    }
-    if (arg->ui & SWITCHTAG_VIEW) {
-        view (&new_arg);
-    }
-    if (arg->ui & SWITCHTAG_TOGGLEVIEW) {
-        toggleview (&new_arg);
-    }
+void
+switchtag(const Arg *arg)
+{
+	unsigned int columns;
+	unsigned int new_tagset = 0;
+	unsigned int pos, i;
+	int col, row;
+	Arg new_arg;
+	
+	columns = (drawtagmask & DRAWCLASSICTAGS) ? LENGTH(tags) : LENGTH(tags) / tagrows + ((LENGTH(tags) % tagrows > 0) ? 1 : 0);
+	
+	for (i = 0; i < LENGTH(tags); ++i) {
+		if (!(selmon->tagset[selmon->seltags] & 1 << i))
+			continue;
+		pos = i;
+		row = pos / columns;
+		col = pos % columns;
+		if (arg->ui & SWITCHTAG_UP) {     /* UP */
+			row --;
+			if (row < 0)
+				row = tagrows - 1;
+			do {
+				pos = row * columns + col;
+				row --;
+			} while (pos >= LENGTH(tags));
+		}
+		if (arg->ui & SWITCHTAG_DOWN) {     /* DOWN */
+			row ++;
+			if (row >= tagrows)
+				row = 0;
+			pos = row * columns + col;
+			if (pos >= LENGTH(tags))
+				row = 0;
+			pos = row * columns + col;
+		}
+		if (arg->ui & SWITCHTAG_LEFT) {     /* LEFT */
+			col --;
+			if (col < 0)
+				col = columns - 1;
+			do {
+				pos = row * columns + col;
+				col --;
+			} while (pos >= LENGTH(tags));
+		}
+		if (arg->ui & SWITCHTAG_RIGHT) {     /* RIGHT */
+			col ++;
+			if (col >= columns)
+				col = 0;
+			pos = row * columns + col;
+			if (pos >= LENGTH(tags)) {
+				col = 0;
+				pos = row * columns + col;
+			}
+		}
+		new_tagset |= 1 << pos;
+	}
+	new_arg.ui = new_tagset;
+	if (arg->ui & SWITCHTAG_TOGGLETAG)
+		toggletag(&new_arg);
+	if (arg->ui & SWITCHTAG_TAG)
+		tag(&new_arg);
+	if (arg->ui & SWITCHTAG_VIEW)
+		view (&new_arg);
+	if (arg->ui & SWITCHTAG_TOGGLEVIEW)
+		toggleview (&new_arg);
 }
 
 void
@@ -5033,6 +4724,7 @@ switchtagpreview(void)
 				image = imlib_create_image(sw, sh);
 				imlib_context_set_image(image);
 				imlib_image_set_has_alpha(1);
+				imlib_context_set_blend(0);
 				imlib_context_set_display(dpy);
 				imlib_context_set_visual(drw->visual);
 				imlib_context_set_drawable(RootWindow(dpy, screen));
@@ -5047,17 +4739,18 @@ switchtagpreview(void)
 }
 
 Monitor *
-systraytomon(Monitor *m) {
+systraytomon(Monitor *m)
+{
 	Monitor *t;
 	int i, n;
-	if(!systraypinning) {
-		if(!m)
+	if (!systraypinning) {
+		if (!m)
 			return selmon;
 		return m == selmon ? m : NULL;
 	}
-	for(n = 1, t = mons; t && t->next; n++, t = t->next) ;
-	for(i = 1, t = mons; t && t->next && i < systraypinning; i++, t = t->next) ;
-	if(systraypinningfailfirst && n < systraypinning)
+	for (n = 1, t = mons; t && t->next; n++, t = t->next);
+	for (i = 1, t = mons; t && t->next && i < systraypinning; i++, t = t->next);
+	if (systraypinningfailfirst && n < systraypinning)
 		return mons;
 	return t;
 }
@@ -5098,13 +4791,13 @@ togglescratch(const Arg *arg)
 			restack(selmon);
 		}
 
-	} else{
+	} else
 		spawnscratch(arg);
-	}
 }
 
 void
-transfer(const Arg *arg) {
+transfer(const Arg *arg)
+{
 	Client *c, *mtail = selmon->clients, *stail = NULL, *insertafter;
 	int transfertostack = 0, i, nmasterclients;
 
@@ -5115,7 +4808,7 @@ transfer(const Arg *arg) {
 		stail = c;
 		i++;
 	}
-	if (selmon->sel->isfloating || i == 0) {
+	if (!selmon->sel || selmon->sel->isfloating || i == 0) {
 		return;
 	} else if (transfertostack) {
 		selmon->nmaster = selmon->pertag->nmasters[selmon->pertag->curtag] = MIN(i, selmon->nmaster) - 1;
@@ -5189,9 +4882,7 @@ updatesystray(void)
 		}
 	}
 
-	drawtheme(0,0,0,0);
 	for (w = 0, i = systray->icons; i; i = i->next) {
-		/* make sure the background color stays the same */
 		wa.background_pixel = 0;
 		XChangeWindowAttributes(dpy, i->win, CWBackPixel, &wa);
 		XMapRaised(dpy, i->win);
@@ -5213,9 +4904,6 @@ updatesystray(void)
 	XConfigureWindow(dpy, systray->win, CWX|CWY|CWWidth|CWHeight|CWSibling|CWStackMode, &wc);
 	XMapWindow(dpy, systray->win);
 	XMapSubwindows(dpy, systray->win);
-	/* redraw background */
-	XSetForeground(dpy, drw->gc, scheme[SchemeBar][bartheme ? ColFloat : ColBg].pixel);
-	XFillRectangle(dpy, systray->win, drw->gc, 0, 0, w, bh);
 	XSync(dpy, False);
 }
 
@@ -5283,6 +4971,8 @@ updatesystrayicongeom(Client *i, int w, int h)
 				i->w = (int) ((float)bh * ((float)i->w / (float)i->h));
 			i->h = bh;
 		}
+		if (i->w > 2*bh)
+			i->w = bh;
 	}
 }
 
@@ -5312,7 +5002,7 @@ updatesystrayiconstate(Client *i, XPropertyEvent *ev)
 		return;
 	sendevent(i->win, xatom[Xembed], StructureNotifyMask, CurrentTime, code, 0,
 			systray->win, XEMBED_EMBEDDED_VERSION);
- }
+}
 
 pid_t
 winpid(Window w)
@@ -5414,12 +5104,12 @@ xinitvisual()
 void
 xrdb(const Arg *arg)
 {
-  loadxrdb();
-  int i;
-  for (i = 0; i < LENGTH(colors); i++)
-                scheme[i] = drw_scm_create(drw, colors[i], alphas[i], 4);
-  focus(NULL);
-  arrange(NULL);
+	loadxrdb();
+	int i;
+	for (i = 0; i < LENGTH(colors); i++)
+		scheme[i] = drw_scm_create(drw, colors[i], alphas[i], 4);
+	focus(NULL);
+	arrange(NULL);
 }
 
 int
@@ -5436,8 +5126,8 @@ main(int argc, char *argv[])
 	if (!(xcon = XGetXCBConnection(dpy)))
 		die("dwm: cannot get xcb connection\n");
 	checkotherwm();
-        XrmInitialize();
-        loadxrdb();
+	XrmInitialize();
+	loadxrdb();
 	setup();
 #ifdef __OpenBSD__
 	if (pledge("stdio rpath proc exec ps", NULL) == -1)
