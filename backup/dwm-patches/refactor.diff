diff --git a/dwm.c b/dwm.c
index a4177e7..7b62ab1 100644
--- a/dwm.c
+++ b/dwm.c
@@ -21,18 +21,18 @@
  * To understand everything else, start reading main().
  */
-#include <math.h>
+#include <time.h>

@@ -140,13 +143,11 @@ struct Client {
-	float floatx, floaty, floatw, floath;
-	int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen, isactfullscreen, isterminal, noswallow;
+	int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen, isterminal, noswallow;

@@ -163,12 +164,6 @@ typedef struct {
 	const Arg arg;
 } Key;
 
-typedef struct {
-	unsigned int signum;
-	void (*func)(const Arg *);
-	const Arg arg;
-} Signal;
-
 typedef struct {
 	const char *symbol;
 	void (*arrange)(Monitor *);
@@ -181,13 +176,12 @@ typedef struct {
-	float floatx, floaty, floatw, floath;
 	int floatborderpx;
 } Rule;
 
@@ -243,13 +237,14 @@ struct Monitor {
 
 struct Pertag {
+	Client *prevzooms[LENGTH(tags) + 1];		/* store zoom information */
 };
 
 /* compile-time check if all tags fit into an unsigned int bit array. */

@@ -260,7 +255,7 @@ void
 applyrules(Client *c)
 {
 	const char *class, *instance;
-	unsigned int i;
+	unsigned int i, newtagset;
 	const Rule *r;
 	Monitor *m;
 	XClassHint ch = { NULL, NULL };
@@ -285,17 +280,26 @@ applyrules(Client *c)
 			c->tags |= r->tags;
 			c->scratchkey = r->scratchkey;
 			c->floatborderpx = r->floatborderpx;
-			c->floatx = r->floatx;
-			c->floaty = r->floaty;
-			c->floatw = r->floatw;
-			c->floath = r->floath;
 			for (m = mons; m && m->num != r->monitor; m = m->next);
 			if (m)
 				c->mon = m;
-			if (r->switchtotag) {
-				Arg a = { .ui = r->tags };
-				c->switchtotag = selmon->tagset[selmon->seltags];
-				view(&a);
+			if (r->switchtag) {
+				selmon = c->mon;
+				if (r->switchtag == 2 || r->switchtag == 4)
+					newtagset = c->mon->tagset[c->mon->seltags] ^ c->tags;
+				else
+					newtagset = c->tags;
+
+				if (newtagset && !(c->tags & c->mon->tagset[c->mon->seltags])) {
+					if (r->switchtag == 3 || r->switchtag == 4)
+						c->switchtag = c->mon->tagset[c->mon->seltags];
+					if (r->switchtag == 1 || r->switchtag == 3)
+						view(&((Arg) { .ui = newtagset }));
+					else {
+						c->mon->tagset[c->mon->seltags] = newtagset;
+						arrange(c->mon);
+					}
+				}
 			}
 		}
 	}
@@ -608,15 +611,13 @@ cleanup(void) SYSDIFF
 	XUngrabKey(dpy, AnyKey, AnyModifier, root);
 	XUnmapWindow(dpy, m->ebarwin);
 	XDestroyWindow(dpy, m->ebarwin);
-    while (mons)
+	while (mons)
 		cleanupmon(mons);
-	if (showsystray && systray) {
+	if (showsystray) {
 		while (systray->icons)
 			removesystrayicon(systray->icons);
-		if (systray->win) {
-			XUnmapWindow(dpy, systray->win);
-			XDestroyWindow(dpy, systray->win);
-		}
+		XUnmapWindow(dpy, systray->win);
+		XDestroyWindow(dpy, systray->win);
 		free(systray);
 	}
 	for (i = 0; i < CurLast; i++)
@@ -706,7 +707,6 @@ clientmessage(XEvent *e) SYSDIFF
 				drawebar(rawstext, selmon, 0);
 			else
 				drawbar(selmon, 0);
-			updatesystray();
 		}
 		return;
 	}
@@ -717,7 +717,7 @@ clientmessage(XEvent *e) SYSDIFF
 		if (cme->data.l[1] == netatom[NetWMFullscreen]
 		|| cme->data.l[2] == netatom[NetWMFullscreen])
 			setfullscreen(c, (cme->data.l[0] == 1 /* _NET_WM_STATE_ADD    */
-				|| cme->data.l[0] == 2 /* _NET_WM_STATE_TOGGLE */));
+				|| (cme->data.l[0] == 2 /* _NET_WM_STATE_TOGGLE */ && !c->isfullscreen)));
 	} else if (cme->message_type == netatom[NetActiveWindow]) {
 		if (c != selmon->sel && !c->isurgent)
 			seturgent(c, 1);
@@ -747,6 +747,7 @@ void
 configurenotify(XEvent *e)
 {
 	Monitor *m;
+	Client *c;
 	XConfigureEvent *ev = &e->xconfigure;
 	int dirty;
 
@@ -759,6 +760,9 @@ configurenotify(XEvent *e)
 			drw_resize(drw, sw, bh);
 			updatebars();
 			for (m = mons; m; m = m->next) {
+				for (c = m->clients; c; c = c->next)
+					if (c->isfullscreen)
+						resizeclient(c, m->mx, m->my, m->mw, m->mh, 0);
 				XMoveResizeWindow(dpy, m->barwin, m->wx + (bargap ? m->gappx : 0), m->by, m->ww - (bargap ? 2 * m->gappx : 0), bh);
 				XMoveResizeWindow(dpy, m->ebarwin, m->wx + (bargap ? m->gappx : 0), m->eby, m->ww - (bargap ? 2 * m->gappx : 0), bh);
 			}
@@ -860,26 +863,11 @@ createmon(void)
 		m->pertag->sellts[i] = m->sellt;
 		m->pertag->showbars[i] = m->showbar;
 		m->pertag->showebars[i] = m->showebar;
+		m->pertag->prevzooms[i] = NULL;
 	}
 	return m;
 }
 
@@ -890,9 +878,11 @@ destroynotify(XEvent *e) SYSDIFF
 		unmanage(c, 1);
 	else if (showsystray && (c = wintosystrayicon(ev->window))) {
 		removesystrayicon(c);
-		updatesystray();
-	}
-	else if ((c = swallowingclient(ev->window)))
+		if (esys)
+			drawebar(rawstext, selmon, 0);
+		else
+			drawbar(selmon, 0);
+	} else if ((c = swallowingclient(ev->window)))
 		unmanage(c->swallowing, 1);
 }
 
 
@@ -995,33 +984,30 @@ int drawtag(Monitor *m, int lr, int p, int xpos) { SYSDIFF
 int drawsystray(Monitor *m, int lr, int p, int xpos) {
 	.....

-		drw_map(drw, esys ? m->ebarwin : m->barwin, x, 0, stw, bh);
 
 		updatesystray();
 	}
@@ -1242,13 +1227,13 @@ drawbar(Monitor *m, int xpos) !!!!!!!!!!!!!!!!!!!!!
 		if (strcmp ("systray", barorder[i]) == 0)
 			lr = drawsystray(m, lr, pos, xpos);
 		if (strcmp ("largesep", barorder[i]) == 0)
-			lr = drawsep(m, lr, pos, xpos, 3);
+			lr = drawsep(m, lr, pos, 3, xpos);
 		if (strcmp ("midsep", barorder[i]) == 0)
-			lr = drawsep(m, lr, pos, xpos, 2);
+			lr = drawsep(m, lr, pos, 2, xpos);
 		if (strcmp ("shortsep", barorder[i]) == 0)
-			lr = drawsep(m, lr, pos, xpos, 1);
+			lr = drawsep(m, lr, pos, 1, xpos);
 	}
-	drawbartabgroups(m, l, r, xpos, 0);
+	drawtabgroups(m, l, r, xpos, 0);
 	drw_map(drw, m->barwin, 0, 0, m->ww, bh);
 }
 
@@ -1268,7 +1253,7 @@ drawebar(char* stext, Monitor *m, int xpos) !!!!!!!!!!!!!!!!!!!!!!
 			lr = drawtag(m, lr, pos, xpos);
 		if (strcmp ("ltsymbol", ebarorder[i]) == 0)
 			lr = drawltsymbol(m, lr, pos, xpos);
-		if (strcmp ("systray", ebarorder[i]) == 0)
+		if (strcmp ("systray", barorder[i]) == 0)
 			lr = drawsystray(m, lr, pos, xpos);
 		if (strcmp ("largesep", ebarorder[i]) == 0)
 			lr = drawsep(m, lr, pos, xpos, 3);

@@ -1332,8 +1317,6 @@ expose(XEvent *e) SYSDIFF
 	if (ev->count == 0 && (m = wintomon(ev->window))) {
 		drawbar(m, 0);
 		drawebar(rawstext, m, 0);
-		if (showsystray && m == selmon)
-			updatesystray();
 	}
 }
 
@@ -1396,7 +1377,7 @@ focusstack(const Arg *arg)
 {
 	Client *c = NULL, *i;
 
-	if (!selmon->sel)
+	if (!selmon->sel || (selmon->sel->isfullscreen && lockfullscreen))
 		return;
 	if (arg->i > 0) {
 		for (c = selmon->sel->next; c && !ISVISIBLE(c); c = c->next);
@@ -1647,47 +1555,6 @@ keypress(XEvent *e)
 			keys[i].func(&(keys[i].arg));
 }
 
-int
-fake_signal(void)
-{
-	char fsignal[256];
-	char indicator[9] = "fsignal:";
-	char str_signum[16];
-	int i, v, signum;
-	size_t len_fsignal, len_indicator = strlen(indicator);
-
-	// Get root name property
-	if (gettextprop(root, XA_WM_NAME, fsignal, sizeof(fsignal))) {
-		len_fsignal = strlen(fsignal);
-
-		// Check if this is indeed a fake signal
-		if (len_indicator > len_fsignal ? 0 : strncmp(indicator, fsignal, len_indicator) == 0) {
-			memcpy(str_signum, &fsignal[len_indicator], len_fsignal - len_indicator);
-			str_signum[len_fsignal - len_indicator] = '\0';
-
-			// Convert string value into managable integer
-			for (i = signum = 0; i < strlen(str_signum); i++) {
-				v = str_signum[i] - '0';
-				if (v >= 0 && v <= 9) {
-					signum = signum * 10 + v;
-				}
-			}
-
-			// Check if a signal was found, and if so handle it
-			if (signum)
-				for (i = 0; i < LENGTH(signals); i++)
-					if (signum == signals[i].signum && signals[i].func)
-						signals[i].func(&(signals[i].arg));
-
-			// A fake signal was sent
-			return 1;
-		}
-	}
-
-	// No fake signal was sent, so proceed with update
-	return 0;
-}
-
 void
 killclient(const Arg *arg)
 {
@@ -1717,7 +1584,6 @@ manage(Window w, XWindowAttributes *wa)
 	c->pid = winpid(w);
 	/* geometry */
 	c->floatborderpx = -1;
-	c->floatx = c->floaty = c->floatw = c->floath = -10;
 	c->x = c->oldx = wa->x;
 	c->y = c->oldy = wa->y;
 	c->w = c->oldw = wa->width;
@@ -1738,75 +1604,22 @@ manage(Window w, XWindowAttributes *wa)
 		term = termforwin(c);
 	}
 
-	if (c->x + WIDTH(c) + 2 * borderpx > c->mon->wx + c->mon->ww)
-		c->x = c->mon->wx + c->mon->ww - WIDTH(c) - 2 * borderpx;
-	if (c->y + HEIGHT(c) + 2 * borderpx > c->mon->wy + c->mon->wh)
-		c->y = c->mon->wy + c->mon->wh - HEIGHT(c) - 2 * borderpx;
-	c->x = MAX(c->x, c->mon->wx);
-	c->y = MAX(c->y, c->mon->wy);
-	if (c->h > c->mon->wh - 2 * borderpx)
-		c->h = c->mon->wh - 2 * borderpx;
-	if (c->w > c->mon->ww - 2 * borderpx)
-		c->w = c->mon->ww - 2 * borderpx;
-	if (c->y < c->mon->wy)
-		c->y = c->mon->wy;
+	if (c->x + WIDTH(c) > c->mon->mx + c->mon->mw)
+		c->x = c->mon->mx + c->mon->mw - WIDTH(c);
+	if (c->y + HEIGHT(c) > c->mon->my + c->mon->mh)
+		c->y = c->mon->my + c->mon->mh - HEIGHT(c);
+	c->x = MAX(c->x, c->mon->mx);
+	/* only fix client y-offset, if the client center might cover the bar */
+	c->y = MAX(c->y, ((c->mon->by == c->mon->my) && (c->x + (c->w / 2) >= c->mon->wx)
+		&& (c->x + (c->w / 2) < c->mon->wx + c->mon->ww)) ? bh : c->mon->my);
 	c->bw = borderpx;
 
-	/* float-dimensions setup */
 	if (c->isfloating && c->floatborderpx >= 0)
 		wc.border_width = c->floatborderpx;
 	else
 		wc.border_width = c->bw;
-
-	if (c->floatx == 0 || c->floatx >= 1)
-		c->x = c->floatx;
-	else if (fabs(c->floatx) > 0 && fabs(c->floatx) < 1)
-		c->x = round(c->mon->mw * 10 / 8 * (fabs(c->floatx) - 0.1) + (bargap ? c->mon->gappx : 0));
-
-	if (c->floaty == 0 || c->floaty >= 1)
-		c->y = c->floaty;
-	else if (c->floaty > 0 && c->floaty < 1)
-		c->y = round(c->mon->wy + (c->floaty - 0.1) * c->mon->wh * 10 / 8);
-	else if (c->floaty < 0 && c->floaty > -1)
-		c->y = round(c->mon->wh * 10 / 8 * (fabs(c->floaty) - 0.1) + (bargap ? c->mon->gappx : 0));
-
-	if (c->floatw > bh)
-		c->w = c->floatw;
-	else if (fabs(c->floatw) > 0 && fabs(c->floatw) < 1)
-		c->w = round(c->mon->mw * 10 / 8 * (fabs(c->floatw) - 0.1) - ((c->floatx == 0 || c->floatx >= 1) ? 0 : (bargap ? c->mon->gappx : 0)) - c->x);
-	if (c->floath > bh)
-		c->h = c->floath;
-	else if (fabs(c->floath) > 0 && fabs(c->floath) < 1) {
-		if (c->floaty == 0 || c->floaty >= 1)
-			c->h = round(c->mon->mh * 10 / 8 * (fabs(c->floath) - 0.1) - c->y);
-		if (c->floaty < 0 && c->floaty > -1)
-			c->h = round(c->mon->mh * 10 / 8 * (fabs(c->floath) - 0.1) - (bargap ? c->mon->gappx : 0) - c->y);
-		else
-			c->h = round(c->mon->wh * 10 / 8 * (fabs(c->floath) - 0.1) - c->y);
-	}
-	if (c->floatx == -1)
-		c->x = round((c->mon->mw - c->w) / 2);
-	if (c->floaty == -1)
-		c->y = round(c->mon->wy + (c->mon->wh - c->h) / 2);
-	if (c->floatx == -2) {	/* this is ugly */
-		c->x =	((int)(xbutt - c->w / 2) < (bargap ? c->mon->gappx : 0))
-					? (bargap ? c->mon->gappx : 0) :
-				((int)(xbutt + c->w / 2) > c->mon->mw - (bargap ? c->mon->gappx : 0))
-					? c->mon->mw - c->w - 2 * wc.border_width - (bargap ? c->mon->gappx : 0)
-				: (xbutt - c->w / 2);
-	}
-	if (c->floaty == -2)
-		c->y = ybutt + bh;
-
 	XConfigureWindow(dpy, w, CWBorderWidth, &wc);
-	if(c->isfloating)
-		XSetWindowBorder(dpy, w, scheme[SchemeBorder][ColFloat].pixel);
-	else {
-		if ( selmon->gappx > 2 * borderpx)
-			XSetWindowBorder(dpy, w, scheme[SchemeBorder][ColBg].pixel);
-		else
-			XSetWindowBorder(dpy, w, scheme[SchemeBorder][ColBorder].pixel);
-	}
+	XSetWindowBorder(dpy, w, scheme[SchemeBorder][c->isfloating ? ColFloat : (selmon->gappx > 2 * borderpx) ? ColBg : ColBorder].pixel);
 	configure(c); /* propagates border_width, if size doesn't change */
 	updatewindowtype(c);
 	updatesizehints(c);
@@ -1902,7 +1713,10 @@ maprequest(XEvent *e) SYSDIFF
 	Client *i;
 	if (showsystray && (i = wintosystrayicon(ev->window))) {
 		sendevent(i->win, netatom[Xembed], StructureNotifyMask, CurrentTime, XEMBED_WINDOW_ACTIVATE, 0, systray->win, XEMBED_EMBEDDED_VERSION);
-		updatesystray();
+		if (esys)
+			drawebar(rawstext, selmon, 0);
+		else
+			drawbar(selmon, 0);
 	}
 
 	if (!XGetWindowAttributes(dpy, ev->window, &wa))
@@ -1974,6 +1788,8 @@ movemouse(const Arg *arg)
 
 	if (!(c = selmon->sel))
 		return;
+	if (c->isfullscreen) /* no support moving fullscreen windows by mouse */
+		return;
 	restack(selmon);
 	ocx = c->x;
 	ocy = c->y;
@@ -2021,162 +1837,6 @@ movemouse(const Arg *arg)
 	}
 }
 
-void
-moveresize(const Arg *arg) {
-	/* only floating windows can be moved */
-	Client *c;
-	c = selmon->sel;
-	int x, y, w, h, nx, ny, nw, nh, ox, oy, ow, oh;
-	char xAbs, yAbs, wAbs, hAbs;
-	int msx, msy, dx, dy, nmx, nmy;
-	unsigned int dui;
-	Window dummy;
-
-	if (!c || !arg)
-		return;
-	if (selmon->lt[selmon->sellt]->arrange && !c->isfloating)
-		return;
-	if (sscanf((char *)arg->v, "%d%c %d%c %d%c %d%c", &x, &xAbs, &y, &yAbs, &w, &wAbs, &h, &hAbs) != 8)
-		return;
-
-	/* compute new window position; prevent window from be positioned outside the current monitor */
-	nw = c->w + w;
-	if (wAbs == 'W')
-		nw = w < selmon->mw - 2 * c->bw ? w : selmon->mw - 2 * c->bw;
-
-	nh = c->h + h;
-	if (hAbs == 'H')
-		nh = h < selmon->mh - 2 * c->bw ? h : selmon->mh - 2 * c->bw;
-
-	nx = c->x + x;
-	if (xAbs == 'X') {
-		if (x < selmon->mx)
-			nx = selmon->mx;
-		else if (x > selmon->mx + selmon->mw)
-			nx = selmon->mx + selmon->mw - nw - 2 * c->bw;
-		else
-			nx = x;
-	}
-
-	ny = c->y + y;
-	if (yAbs == 'Y') {
-		if (y < selmon->my)
-			ny = selmon->my;
-		else if (y > selmon->my + selmon->mh)
-			ny = selmon->my + selmon->mh - nh - 2 * c->bw;
-		else
-			ny = y;
-	}
-
-	ox = c->x;
-	oy = c->y;
-	ow = c->w;
-	oh = c->h;
-
-	XRaiseWindow(dpy, c->win);
-	Bool xqp = XQueryPointer(dpy, root, &dummy, &dummy, &msx, &msy, &dx, &dy, &dui);
-	resize(c, nx, ny, nw, nh, c->bw, True);
-
-	/* move cursor along with the window to avoid problems caused by the sloppy focus */
-	if (xqp && ox <= msx && (ox + ow) >= msx && oy <= msy && (oy + oh) >= msy)
-	{
-		nmx = c->x - ox + c->w - ow;
-		nmy = c->y - oy + c->h - oh;
-		XWarpPointer(dpy, None, None, 0, 0, 0, 0, nmx, nmy);
-	}
-}
-
-void
-moveresizeedge(const Arg *arg) {
-	/* move or resize floating window to edge of screen */
-	Client *c;
-	c = selmon->sel;
-	char e;
-	int nx, ny, nw, nh, ox, oy, ow, oh, bp;
-	int msx, msy, dx, dy, nmx, nmy;
-	int starty;
-	unsigned int dui;
-	Window dummy;
-
-	nx = c->x;
-	ny = c->y;
-	nw = c->w;
-	nh = c->h;
-
-	if(abs(selmon->showbar) + abs(selmon->showebar) == 2) {
-		starty = topbar ? 2 * bh : 0;
-		bp = !topbar ? 2 * bh : 0;
-	} else if(abs(selmon->showbar) + abs(selmon->showebar) == 1) {
-		starty = topbar ? bh : 0;
-		bp = !topbar ? bh : 0;
-	} else {
-		starty = 0;
-		bp = 0;
-	}
-
-	if (!c || !arg)
-		return;
-	if (selmon->lt[selmon->sellt]->arrange && !c->isfloating)
-		return;
-	if(sscanf((char *)arg->v, "%c", &e) != 1)
-		return;
-
-	if(e == 't')
-		ny = starty;
-
-	if(e == 'b')
-		ny = c->h > selmon->mh - 2 * c->bw ? c->h - bp : selmon->mh - c->h - 2 * c->bw - bp;
-
-	if(e == 'l')
-		nx = selmon->mx;
-
-	if(e == 'r')
-		nx = c->w > selmon->mw - 2 * c->bw ? selmon->mx + c->w : selmon->mx + selmon->mw - c->w - 2 * c->bw;
-
-	if(e == 'T') {
-		/* if you click to resize again, it will return to old size/position */
-		if(c->h + starty == c->oldh + c->oldy) {
-			nh = c->oldh;
-			ny = c->oldy;
-		} else {
-			nh = c->h + c->y - starty;
-			ny = starty;
-		}
-	}
-
-	if(e == 'B')
-		nh = c->h + c->y + 2 * c->bw + bp == selmon->mh ? c->oldh : selmon->mh - c->y - 2 * c->bw - bp;
-
-	if(e == 'L') {
-		if(selmon->mx + c->w == c->oldw + c->oldx) {
-			nw = c->oldw;
-			nx = c->oldx;
-		} else {
-			nw = c->w + c->x - selmon->mx;
-			nx = selmon->mx;
-		}
-	}
-
-	if(e == 'R')
-		nw = c->w + c->x + 2 * c->bw == selmon->mx + selmon->mw ? c->oldw : selmon->mx + selmon->mw - c->x - 2 * c->bw;
-
-	ox = c->x;
-	oy = c->y;
-	ow = c->w;
-	oh = c->h;
-
-	XRaiseWindow(dpy, c->win);
-	Bool xqp = XQueryPointer(dpy, root, &dummy, &dummy, &msx, &msy, &dx, &dy, &dui);
-	resize(c, nx, ny, nw, nh, c->bw, True);
-
-	/* move cursor along with the window to avoid problems caused by the sloppy focus */
-	if (xqp && ox <= msx && (ox + ow) >= msx && oy <= msy && (oy + oh) >= msy) {
-		nmx = c->x - ox + c->w - ow;
-		nmy = c->y - oy + c->h - oh;
-		XWarpPointer(dpy, None, None, 0, 0, 0, 0, nmx, nmy);
-	}
-}
-
 Client *
 nexttiled(Client *c)
 {
@@ -2207,13 +1867,15 @@ propertynotify(XEvent *e)  SYSDIFF
 		}
 		else
 			updatesystrayiconstate(c, ev);
-		updatesystray();
+		if (esys)
+			drawebar(rawstext, selmon, 0);
+		else
+			drawbar(selmon, 0);
 	}
 
-	if ((ev->window == root) && (ev->atom == XA_WM_NAME)) {
-		if (!fake_signal())
-			updatestatus();
-	} else if (ev->state == PropertyDelete)
+	if ((ev->window == root) && (ev->atom == XA_WM_NAME))
+		updatestatus();
+	else if (ev->state == PropertyDelete)
 		return; /* ignore */
 	else if ((c = wintoclient(ev->window))) {
 		switch(ev->atom) {
@@ -2246,25 +1907,6 @@ propertynotify(XEvent *e)
 	}
 }
 
-Client *
-nextc(Client *c, float f) {
-	if(!f)
-		return nexttiled(c);
-
-	for(; c && !ISVISIBLE(c); c = c->next);
-	return c;
-}
-
-static Client *
-prevc(Client *c, float f) {
-	Client *p, *r;
-
-	for(p = selmon->clients, r = NULL; c && p && p != c; p = p->next)
-		if((f || !p->isfloating) && ISVISIBLE(p))
-			r = p;
-	return r;
-}
-
 void
 quit(const Arg *arg)
 {
@@ -2316,17 +1958,19 @@ resizemouse(const Arg *arg)
 
 	if (!(c = selmon->sel))
 		return;
+	if (c->isfullscreen) /* no support resizing fullscreen windows by mouse */
+		return;
 	restack(selmon);
 	ocx = c->x;
 	ocy = c->y;
@@ -2485,6 +2128,8 @@ sendmon(Client *c, Monitor *m)
 	attachstack(c);
 	focus(NULL);
 	arrange(NULL);
+	if (c->switchtag)
+		c->switchtag = 0;
 }
 
 void
@@ -2543,42 +2188,33 @@ setfocus(Client *c)
 }
 
 void
-setactfullscreen(Client *c)
+setfullscreen(Client *c, int fullscreen)
 {
-	if (!c->isactfullscreen) {
-		c->isactfullscreen = 1;
+	if (fullscreen && !c->isfullscreen) {
+		XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
+			PropModeReplace, (unsigned char*)&netatom[NetWMFullscreen], 1);
+		c->isfullscreen = 1;
 		c->oldstate = c->isfloating;
+		c->oldbw = c->bw;
+		c->bw = 0;
 		c->isfloating = 1;
 		resizeclient(c, c->mon->mx, c->mon->my, c->mon->mw, c->mon->mh, 0);
 		XRaiseWindow(dpy, c->win);
-	} else if (c->isactfullscreen){
-		c->isactfullscreen = 0;
+	} else if (!fullscreen && c->isfullscreen){
+		XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
+			PropModeReplace, (unsigned char*)0, 0);
+		c->isfullscreen = 0;
 		c->isfloating = c->oldstate;
+		c->bw = c->oldbw;
 		c->x = c->oldx;
 		c->y = c->oldy;
 		c->w = c->oldw;
 		c->h = c->oldh;
-		c->bw = c->oldbw;
 		resizeclient(c, c->x, c->y, c->w, c->h, c->bw);
 		arrange(c->mon);
 	}
 }
 
-void
-setfullscreen(Client *c, int fullscreen)
-{
-	if (fullscreen && !c->isfullscreen) {
-		XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
-			PropModeReplace, (unsigned char*)&netatom[NetWMFullscreen], 1);
-		c->isfullscreen = 1;
-	} else if (!fullscreen && c->isfullscreen){
-		XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
-			PropModeReplace, (unsigned char*)0, 0);
-		c->isfullscreen = 0;
-	}
-    demoncleaner(0);
-}
-
 void
 setlayout(const Arg *arg)
 {
@@ -2727,9 +2363,8 @@ showhide(Client *c)
 	if (ISVISIBLE(c)) {
 		/* show clients top down */
 		XMoveWindow(dpy, c->win, c->x, c->y);
-		if (!c->mon->lt[c->mon->sellt]->arrange || c->isfloating)
+		if ((!c->mon->lt[c->mon->sellt]->arrange || c->isfloating) && !c->isfullscreen)
 			resize(c, c->x, c->y, c->w, c->h, c->bw, 0);
-//			resize(c, c->x, c->y, c->w, c->h, borderpx, 0);
 		showhide(c->snext);
 	} else {
 		/* hide clients bottom up */
@@ -2779,6 +2414,8 @@ tag(const Arg *arg)
 {
 	if (selmon->sel && arg->ui & TAGMASK) {
 		selmon->sel->tags = arg->ui & TAGMASK;
+		if (selmon->sel->switchtag)
+			selmon->sel->switchtag = 0;
 		focus(NULL);
 		arrange(selmon);
 	}
@@ -2966,7 +2603,7 @@ togglebar(const Arg *arg) !!!!!!!!!!!!!!!!1
 	}
 	XMoveWindow(dpy, selmon->barwin, selmon->wx + (bargap ? selmon->gappx : 0), selmon->by);
 	XMoveWindow(dpy, selmon->ebarwin, selmon->wx + (bargap ? selmon->gappx : 0), selmon->eby);
-	XMoveWindow(dpy, selmon->tagwin, rtag ? selmon->ww - selmon->ww / scalepreview - (bargap ? selmon->gappx : 0) : selmon->wx + (bargap ? selmon->gappx : 0), selmon->wy);
+	XMoveResizeWindow(dpy, selmon->tagwin, rtag ? selmon->ww - selmon->ww / scalepreview - (bargap ? selmon->gappx : 0) : selmon->wx + (bargap ? selmon->gappx : 0), selmon->wy, sw / scalepreview, sh / scalepreview);
 	arrange(selmon);
 }
 
@@ -2988,7 +2625,7 @@ toggleebar(const Arg *arg)
 	}
 	XMoveWindow(dpy, selmon->barwin, selmon->wx + (bargap ? selmon->gappx : 0), selmon->by);
 	XMoveWindow(dpy, selmon->ebarwin, selmon->wx + (bargap ? selmon->gappx : 0), selmon->eby);
-	XMoveWindow(dpy, selmon->tagwin, rtag ? selmon->ww - selmon->ww / scalepreview - (bargap ? selmon->gappx : 0) : selmon->wx + (bargap ? selmon->gappx : 0), selmon->wy);
+	XMoveResizeWindow(dpy, selmon->tagwin, rtag ? selmon->ww - selmon->ww / scalepreview - (bargap ? selmon->gappx : 0) : selmon->wx + (bargap ? selmon->gappx : 0), selmon->wy, sw / scalepreview, sh / scalepreview);
     arrange(selmon);
 }
 
@@ -3010,7 +2647,10 @@ togglefloating(const Arg *arg)
 {
 	if (!selmon->sel)
 		return;
+	if (selmon->sel->isfullscreen) /* no support for fullscreen windows */
+		return;
 	selmon->sel->isfloating = !selmon->sel->isfloating || selmon->sel->isfixed;
+	XSetWindowBorder(dpy, selmon->sel->win, scheme[SchemeBorder][selmon->sel->isfloating ? ColFloat : ColBorder].pixel);
 	if (selmon->sel->isfloating)
 		/* restore last known float dimensions */
 		resize(selmon->sel, selmon->sel->sfx, selmon->sel->sfy,
@@ -3029,18 +2669,10 @@ togglefloating(const Arg *arg)
 	arrangemon(selmon);
 }
 
-void
-togglefullscr(const Arg *arg)
-{
-  if(selmon->sel)
-    setactfullscreen(selmon->sel);
-}
-
 void
 toggletag(const Arg *arg)
 {
-	unsigned int newtags;
-	unsigned int i;
+	unsigned int i, newtags;
 
 	if (!selmon->sel)
 		return;
@@ -3087,38 +2719,32 @@ toggleview(const Arg *arg)   !!!!!!!!!!!!!!!
 	size_t j;
 	for (c = nexttiled(selmon->clients), j = 0; c && j < selmon->nmaster; c = nexttiled(c->next), ++j)
 		masters[selmon->nmaster - (j + 1)] = c;
-	for (size_t j = 0; j < selmon->nmaster; ++j)
+	for (j = 0; j < selmon->nmaster; ++j)
 		if (masters[j])
 			pop(masters[j]);
 	free(masters);
 	focus(selected);
+
 	if (newtagset) {
 		selmon->tagset[selmon->seltags] = newtagset;
-
 		if (newtagset == ~0) {
 			selmon->pertag->prevtag = selmon->pertag->curtag;
 			selmon->pertag->curtag = 0;
 		}
-
 		/* test if the user did not select the same tag */
 		if (!(newtagset & 1 << (selmon->pertag->curtag - 1))) {
 			selmon->pertag->prevtag = selmon->pertag->curtag;
 			for (i = 0; !(newtagset & 1 << i); i++) ;
 			selmon->pertag->curtag = i + 1;
 		}
-
 		/* apply settings for this view */
 		selmon->nmaster = selmon->pertag->nmasters[selmon->pertag->curtag];
 		selmon->mfact = selmon->pertag->mfacts[selmon->pertag->curtag];
 		selmon->sellt = selmon->pertag->sellts[selmon->pertag->curtag];
 		selmon->lt[selmon->sellt] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt];
 		selmon->lt[selmon->sellt^1] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt^1];
-
 		if (selmon->showbar != selmon->pertag->showbars[selmon->pertag->curtag]) 			!!!!!!!!!!!!!!!
 			togglebar(NULL);
-		if (selmon->showebar != selmon->pertag->showebars[selmon->pertag->curtag])
-			toggleebar(NULL);
-
 		focus(NULL);
 		arrange(selmon);
 	}
@@ -3130,14 +2756,7 @@ unfocus(Client *c, int setfocus)
 	if (!c)
 		return;
 	grabbuttons(c, 0);
-	if(c->isfloating)
-		XSetWindowBorder(dpy, c->win, scheme[SchemeBorder][ColFloat].pixel);
-	else {
-		if ( selmon->gappx > borderpx)
-			XSetWindowBorder(dpy, c->win, scheme[SchemeBorder][ColBg].pixel);
-		else
-			XSetWindowBorder(dpy, c->win, scheme[SchemeBorder][ColBorder].pixel);
-	}
+	XSetWindowBorder(dpy, c->win, scheme[SchemeBorder][c->isfloating ? ColFloat : (selmon->gappx > borderpx) ? ColBg : ColBorder].pixel);
 	if (setfocus) {
 		XSetInputFocus(dpy, root, RevertToPointerRoot, CurrentTime);
 		XDeleteProperty(dpy, root, netatom[NetActiveWindow]);
@@ -3149,11 +2768,11 @@ unmanage(Client *c, int destroyed)
 {
 	Client *s;
 	Monitor *m = c->mon;
+	unsigned int switchtag = c->switchtag;
 	XWindowChanges wc;
 
 	if (c->swallowing)
 		unswallow(c);
-
 	s = swallowingclient(c->win);
 	if (s)
 		s->swallowing = NULL;
@@ -3176,10 +2795,8 @@ unmanage(Client *c, int destroyed)
 	focus(NULL);
 	updateclientlist();
 	arrange(m);
-	if (c->switchtotag) {
-		Arg a = { .ui = c->switchtotag };
-		view(&a);
-	}
+	if (switchtag)
+		view(&((Arg) { .ui = switchtag }));
 }
 
 void
@@ -3197,8 +2814,10 @@ unmapnotify(XEvent *e)  SYSDIFF
 		/* KLUDGE! sometimes icons occasionally unmap their windows, but do
 		 * _not_ destroy them. We map those windows back */
 		XMapRaised(dpy, c->win);
-		removesystrayicon(c);
-		updatesystray();
+		if (esys)
+			drawebar(rawstext, selmon, 0);
+		else
+			drawbar(selmon, 0);
 	}
 }
 
@@ -3625,30 +3243,31 @@ void
 zoom(const Arg *arg)
 {
 	Client *c = selmon->sel;
-	Client *at = NULL, *cold, *cprevious = NULL;
+	Client *at = NULL, *cold, *cprevious = NULL, *p;
 
 	if (!selmon->lt[selmon->sellt]->arrange
-	|| (selmon->sel && selmon->sel->isfloating))
+	|| (selmon->sel && selmon->sel->isfloating) || !c)
 		return;
-	if (c == nexttiled(selmon->clients)) {
-		at = findbefore(prevzoom);
+	if (c == nexttiled(c->mon->clients)) {
+		p = c->mon->pertag->prevzooms[c->mon->pertag->curtag];
+		at = findbefore(p);
 		if (at)
 			cprevious = nexttiled(at->next);
-		if (!cprevious || cprevious != prevzoom) {
-			prevzoom = NULL;
+		if (!cprevious || cprevious != p) {
+			c->mon->pertag->prevzooms[c->mon->pertag->curtag] = NULL;
 			if (!c || !(c = nexttiled(c->next)))
 				return;
 		} else
 			c = cprevious;
 	}
-	cold = nexttiled(selmon->clients);
+	cold = nexttiled(c->mon->clients);
 	if (c != cold && !at)
 		at = findbefore(c);
 	detach(c);
 	attach(c);
 	/* swap windows instead of pushing the previous one down */
 	if (c != cold && at) {
-		prevzoom = cold;
+		c->mon->pertag->prevzooms[c->mon->pertag->curtag] = cold;
 		if (cold && at != cold) {
 			detach(cold);
 			cold->next = at->next;
@@ -3729,13 +3348,12 @@ attachtop(Client *c)  ??????????????? zoomswap from bakky!!!!
 }
 
 Client *
-findbefore(Client *c)
-{
-	Client *tmp;
-	if (c == selmon->clients)
+findbefore(Client *c) {
+	Client *p;
+	if (!c || c == c->mon->clients)
 		return NULL;
-	for (tmp = selmon->clients; tmp && tmp->next != c; tmp = tmp->next);
-	return tmp;
+	for (p = c->mon->clients; p && p->next != c; p = p->next);
+	return p;
 }
 
 void
@@ -4196,46 +3817,44 @@ void drawtaggrid
.....
-               XSetForeground(drw->dpy, drw->gc, scheme[SchemeTag][ColFloat].pixel);
+				XSetForeground(drw->dpy, drw->gc, !invert ? scheme[SchemeTag][ColBg].pixel : scheme[SchemeTag][ColFloat].pixel);
....
 
@@ -4343,7 +4035,7 @@ inplacerotate(const Arg *arg)
 	unsigned int selidx = 0, i = 0;
 	Client *c = NULL, *stail = NULL, *mhead = NULL, *mtail = NULL, *shead = NULL;
 
-	// Shift client
+	// Determine positionings for insertclient
 	for (c = selmon->clients; c; c = c->next) {
 		if (ISVISIBLE(c) && !(c->isfloating)) {
 		if (selmon->sel == c) { selidx = i; }
@@ -4354,10 +4046,15 @@ inplacerotate(const Arg *arg)
 		i++;
 		}
 	}
-	if (arg->i < 0 && selidx >= selmon->nmaster) insertclient(stail, shead, 1);
-	if (arg->i > 0 && selidx >= selmon->nmaster) insertclient(shead, stail, 0);
-	if (arg->i < 0 && selidx < selmon->nmaster)  insertclient(mtail, mhead, 1);
-	if (arg->i > 0 && selidx < selmon->nmaster)  insertclient(mhead, mtail, 0);
+
+	// All clients rotate
+	if (arg->i == 2) insertclient(selmon->clients, stail, 0);
+	if (arg->i == -2) insertclient(stail, selmon->clients, 1);
+	// Stack xor master rotate
+	if (arg->i == -1 && selidx >= selmon->nmaster) insertclient(stail, shead, 1);
+	if (arg->i == 1 && selidx >= selmon->nmaster) insertclient(shead, stail, 0);
+	if (arg->i == -1 && selidx < selmon->nmaster)  insertclient(mtail, mhead, 1);
+	if (arg->i == 1 && selidx < selmon->nmaster)  insertclient(mhead, mtail, 0);
 
 	// Restore focus position
 	i = 0;

@@ -4474,27 +4170,34 @@ void
 notifyhandler(const Arg *arg)
 {
 	if (arg->i == 1) {
-		istatustimer = eblock = esep = 0;
+		istatustimer = fblock = fsep = 0;
 		strncpy(rawstext, stext, sizeof(stext));
 		copyvalidchars(stext, rawstext);
 		drawebar(rawstext, selmon, 0);
 	}
 }
 
-static void
+Client *
+prevtiled(Client *c) {
+	Client *p, *r;
+
+	for(p = selmon->clients, r = NULL; p && p != c; p = p->next)
+		if(!p->isfloating && ISVISIBLE(p))
+			r = p;
+	return r;
+}
+
+void
 pushdown(const Arg *arg) {
-	Client *sel = selmon->sel;
-	Client *c;
+	Client *sel = selmon->sel, *c;
 
-	if(!sel || (sel->isfloating && !arg->f))
+	if(!sel || sel->isfloating)
 		return;
-	if((c = nextc(sel->next, arg->f))) {
-		/* attach after c */
+	if((c = nexttiled(sel->next))) {
 		detach(sel);
 		sel->next = c->next;
 		c->next = sel;
 	} else {
-		/* move to the front */
 		detach(sel);
 		attach(sel);
 	}
@@ -4502,15 +4205,13 @@ pushdown(const Arg *arg) {
 	arrange(selmon);
 }
 
-static void
+void
 pushup(const Arg *arg) {
-	Client *sel = selmon->sel;
-	Client *c;
+	Client *sel = selmon->sel, *c;
 
-	if(!sel || (sel->isfloating && !arg->f))
+	if(!sel || sel->isfloating)
 		return;
-	if((c = prevc(sel, arg->f))) {
-		/* attach before c */
+	if((c = prevtiled(sel))) {
 		detach(sel);
 		sel->next = c;
 		if(selmon->clients == c)
@@ -4520,7 +4221,6 @@ pushup(const Arg *arg) {
 			c->next = sel;
 		}
 	} else {
-		/* move to the end */
 		for(c = sel; c->next; c = c->next);
 		detach(sel);
 		sel->next = NULL;
@@ -4591,7 +4291,10 @@ resizerequest(XEvent *e)  SYSDIFF
 
 	if ((i = wintosystrayicon(ev->window))) {
 		updatesystrayicongeom(i, ev->width, ev->height);
-		updatesystray();
+		if (esys)
+			drawebar(rawstext, selmon, 0);
+		else
+			drawbar(selmon, 0);
 	}
 }
 
@@ -4761,15 +4464,13 @@ setgaps(const Arg *arg) !!!!!!!!!!!!
 	Client *c;
 	if ((arg->i == 0) || (selmon->gappx + arg->i < 0))
 		selmon->gappx = 0;
-	else {
-		if (selmon->gappx + arg->i < 50)
+	else if (selmon->gappx + arg->i < 50)
 		selmon->gappx += arg->i;
-		}
 	updatebarpos(selmon);
 	if (bargap) {
 		XMoveResizeWindow(dpy, selmon->barwin, selmon->wx + selmon->gappx, selmon->by, selmon->ww - 2 * selmon->gappx, bh);
 		XMoveResizeWindow(dpy, selmon->ebarwin, selmon->wx + selmon->gappx, selmon->eby, selmon->ww - 2 * selmon->gappx, bh);
-		XMoveWindow(dpy, selmon->tagwin, rtag ? selmon->ww - selmon->gappx - selmon->ww / scalepreview : selmon->wx + selmon->gappx, selmon->wy);
+		XMoveResizeWindow(dpy, selmon->tagwin, rtag ? selmon->ww - selmon->gappx - selmon->ww / scalepreview : selmon->wx + selmon->gappx, selmon->wy, sw / scalepreview, sh / scalepreview);
 	}
 	if ((selmon->gappx == 1 * borderpx && arg->i < 0)) {
 		for (c = nexttiled(selmon->clients); c; c = nexttiled(c->next))
@@ -5032,6 +4724,7 @@ switchtagpreview(void)
 				image = imlib_create_image(sw, sh);
 				imlib_context_set_image(image);
 				imlib_image_set_has_alpha(1);
+				imlib_context_set_blend(0);
 				imlib_context_set_display(dpy);
 				imlib_context_set_visual(drw->visual);
 				imlib_context_set_drawable(RootWindow(dpy, screen));
@@ -5114,7 +4808,7 @@ transfer(const Arg *arg) {  ????
 		stail = c;
 		i++;
 	}
-	if (selmon->sel->isfloating || i == 0) {
+	if (!selmon->sel || selmon->sel->isfloating || i == 0) {
 		return;
 	} else if (transfertostack) {
 		selmon->nmaster = selmon->pertag->nmasters[selmon->pertag->curtag] = MIN(i, selmon->nmaster) - 1;
@@ -5188,9 +4882,7 @@ updatesystray(void)  SYSDIFF
 		}
 	}
 
-	drawtheme(0,0,0,0);
 	for (w = 0, i = systray->icons; i; i = i->next) {
-		/* make sure the background color stays the same */
 		wa.background_pixel = 0;
 		XChangeWindowAttributes(dpy, i->win, CWBackPixel, &wa);
 		XMapRaised(dpy, i->win);
@@ -5212,9 +4904,6 @@ updatesystray(void)  SYSDIFF
 	XConfigureWindow(dpy, systray->win, CWX|CWY|CWWidth|CWHeight|CWSibling|CWStackMode, &wc);
 	XMapWindow(dpy, systray->win);
 	XMapSubwindows(dpy, systray->win);
-	/* redraw background */
-	XSetForeground(dpy, drw->gc, scheme[SchemeBar][bartheme ? ColFloat : ColBg].pixel);
-	XFillRectangle(dpy, systray->win, drw->gc, 0, 0, w, bh);
 	XSync(dpy, False);
 }
 
@@ -5282,6 +4971,8 @@ updatesystrayicongeom(Client *i, int w, int h)  SYSDIFF
 				i->w = (int) ((float)bh * ((float)i->w / (float)i->h));
 			i->h = bh;
 		}
+		if (i->w > 2*bh)
+			i->w = bh;
 	}
 }
